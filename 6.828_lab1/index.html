<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>6.828_lab1 - Zhou X&#39;s Blog</title><meta name="Description" content="这是我的全新 Hugo 网站"><meta property="og:title" content="6.828_lab1" />
<meta property="og:description" content="lab1 part1 PC Bootstrap 实验分为三个部分： 熟悉汇编语言、QEMU x86模拟器、PC上电启动过程 检查我们的6.828内核的boot loader程序，它位于la" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.zhouxingjie.work/6.828_lab1/" /><meta property="og:image" content="https://www.zhouxingjie.work/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-31T21:10:57+08:00" />
<meta property="article:modified_time" content="2023-10-31T23:46:52+08:00" /><meta property="og:site_name" content="我的网站" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://www.zhouxingjie.work/logo.png"/>

<meta name="twitter:title" content="6.828_lab1"/>
<meta name="twitter:description" content="lab1 part1 PC Bootstrap 实验分为三个部分： 熟悉汇编语言、QEMU x86模拟器、PC上电启动过程 检查我们的6.828内核的boot loader程序，它位于la"/>
<meta name="application-name" content="我的网站">
<meta name="apple-mobile-web-app-title" content="我的网站"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://www.zhouxingjie.work/6.828_lab1/" /><link rel="next" href="https://www.zhouxingjie.work/6.828_lab2/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "6.828_lab1",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/www.zhouxingjie.work\/6.828_lab1\/"
        },"genre": "posts","wordcount":  21085 ,
        "url": "https:\/\/www.zhouxingjie.work\/6.828_lab1\/","datePublished": "2023-10-31T21:10:57+08:00","dateModified": "2023-10-31T23:46:52+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "zhouxingjie"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Zhou X&#39;s Blog"></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Zhou X&#39;s Blog"></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">6.828_lab1</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>zhouxingjie</a></span>&nbsp;<span class="post-category">included in <a href="/categories/6.828/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>6.828</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2023-10-31">2023-10-31</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;21085 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;43 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="true">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#part1-pc-bootstrap">part1 PC Bootstrap</a>
      <ul>
        <li><a href="#the-pcs-physical-address-space">The PC’s Physical Address Space</a></li>
        <li><a href="#the-rom-bios">The ROM BIOS</a></li>
      </ul>
    </li>
    <li><a href="#part2-the-bootloader">Part2 The BootLoader</a>
      <ul>
        <li><a href="#实模式和保护模式">实模式和保护模式</a></li>
        <li><a href="#bootsmainc">Boot.S&amp;main.c</a></li>
        <li><a href="#exercise3">exercise3</a></li>
        <li><a href="#loading-the-kernel">Loading the kernel</a></li>
        <li><a href="#exercise4">exercise4</a>
          <ul>
            <li><a href="#elf文件格式简图">ELF文件格式简图</a></li>
          </ul>
        </li>
        <li><a href="#exercise5">exercise5</a></li>
        <li><a href="#exercies6">exercies6</a></li>
      </ul>
    </li>
    <li><a href="#part3-the-kernel">Part3 The Kernel</a>
      <ul>
        <li><a href="#exercise7">exercise7</a></li>
        <li><a href="#exercise8">exercise8</a></li>
        <li><a href="#the-stack">The Stack</a></li>
        <li><a href="#exercise9">exercise9</a></li>
        <li><a href="#exercise10">exercise10</a></li>
        <li><a href="#exercise11">exercise11</a></li>
        <li><a href="#exercise12">exercise12</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="lab1">lab1</h1>
<h2 id="part1-pc-bootstrap">part1 PC Bootstrap</h2>
<p>实验分为三个部分：</p>
<ul>
<li>熟悉汇编语言、QEMU x86模拟器、PC上电启动过程</li>
<li>检查我们的6.828内核的boot loader程序，它位于<code>lab</code>的<code>boot</code>目录下。</li>
<li>深入研究6.828内核本身的初始模板，位于<code>kernel</code>目录下。</li>
</ul>
<p>使用qemu编译</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="err">$</span> <span class="n">make</span> <span class="n">qemu</span><span class="o">-</span><span class="n">nox</span><span class="o">-</span><span class="n">gdb</span>
</span></span><span class="line"><span class="cl"><span class="o">***</span>
</span></span><span class="line"><span class="cl"><span class="o">***</span> <span class="n">Now</span> <span class="n">run</span> <span class="err">&#39;</span><span class="n">make</span> <span class="n">gdb</span><span class="err">&#39;</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="o">***</span>
</span></span><span class="line"><span class="cl"><span class="n">qemu</span><span class="o">-</span><span class="n">system</span><span class="o">-</span><span class="n">i386</span> <span class="o">-</span><span class="n">nographic</span> <span class="o">-</span><span class="n">drive</span> <span class="n">file</span><span class="o">=</span><span class="n">obj</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">kernel</span><span class="p">.</span><span class="n">img</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">media</span><span class="o">=</span><span class="n">disk</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="n">raw</span> <span class="o">-</span><span class="n">serial</span> <span class="nl">mon</span><span class="p">:</span><span class="n">stdio</span> <span class="o">-</span><span class="n">gdb</span> <span class="n">tcp</span><span class="o">::</span><span class="mi">26002</span> <span class="o">-</span><span class="n">D</span> <span class="n">qemu</span><span class="p">.</span><span class="n">log</span>  <span class="o">-</span><span class="n">S</span>
</span></span><span class="line"><span class="cl"><span class="mi">6828</span> <span class="n">decimal</span> <span class="n">is</span> <span class="n">XXX</span> <span class="n">octal</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">Welcome</span> <span class="n">to</span> <span class="n">the</span> <span class="n">JOS</span> <span class="n">kernel</span> <span class="n">monitor</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="n">Type</span> <span class="err">&#39;</span><span class="n">help</span><span class="err">&#39;</span> <span class="k">for</span> <span class="n">a</span> <span class="n">list</span> <span class="n">of</span> <span class="n">commands</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="n">K</span><span class="o">&gt;</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用help和kerninfo两个命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">K</span><span class="o">&gt;</span> <span class="n">help</span>
</span></span><span class="line"><span class="cl"><span class="n">help</span> <span class="o">-</span> <span class="n">Display</span> <span class="n">this</span> <span class="n">list</span> <span class="n">of</span> <span class="n">commands</span>
</span></span><span class="line"><span class="cl"><span class="n">kerninfo</span> <span class="o">-</span> <span class="n">Display</span> <span class="n">information</span> <span class="n">about</span> <span class="n">the</span> <span class="n">kernel</span>
</span></span><span class="line"><span class="cl"><span class="n">K</span><span class="o">&gt;</span> <span class="n">kerninfo</span>
</span></span><span class="line"><span class="cl"><span class="n">Special</span> <span class="n">kernel</span> <span class="nl">symbols</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">_start</span>                  <span class="mo">0010000</span><span class="n">c</span> <span class="p">(</span><span class="n">phys</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">entry</span>  <span class="nf">f010000c</span> <span class="p">(</span><span class="n">virt</span><span class="p">)</span>  <span class="mo">0010000</span><span class="n">c</span> <span class="p">(</span><span class="n">phys</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">etext</span>  <span class="nf">f0101acd</span> <span class="p">(</span><span class="n">virt</span><span class="p">)</span>  <span class="mo">00101</span><span class="n">acd</span> <span class="p">(</span><span class="n">phys</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">edata</span>  <span class="nf">f0113060</span> <span class="p">(</span><span class="n">virt</span><span class="p">)</span>  <span class="mo">00113060</span> <span class="p">(</span><span class="n">phys</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">end</span>    <span class="nf">f01136a0</span> <span class="p">(</span><span class="n">virt</span><span class="p">)</span>  <span class="mo">001136</span><span class="n">a0</span> <span class="p">(</span><span class="n">phys</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Kernel</span> <span class="n">executable</span> <span class="n">memory</span> <span class="nl">footprint</span><span class="p">:</span> <span class="mi">78</span><span class="n">KB</span>
</span></span><span class="line"><span class="cl"><span class="n">K</span><span class="o">&gt;</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="the-pcs-physical-address-space">The PC’s Physical Address Space</h3>
<p>接下来会介绍PC的启动。一个PC的物理地址空间可以分成以下组成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">We will now dive into a bit more detail about how a PC starts up. A PC&#39;s physical address space is hard-wired to have the following general layout:
</span></span><span class="line"><span class="cl">+------------------+  &lt;- 0xFFFFFFFF (4GB)
</span></span><span class="line"><span class="cl">|      32-bit      |
</span></span><span class="line"><span class="cl">|  memory mapped   |
</span></span><span class="line"><span class="cl">|     devices      |
</span></span><span class="line"><span class="cl">|                  |
</span></span><span class="line"><span class="cl">/\/\/\/\/\/\/\/\/\/\
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/\/\/\/\/\/\/\/\/\/\
</span></span><span class="line"><span class="cl">|                  |
</span></span><span class="line"><span class="cl">|      Unused      |
</span></span><span class="line"><span class="cl">|                  |
</span></span><span class="line"><span class="cl">+------------------+  &lt;- depends on amount of RAM
</span></span><span class="line"><span class="cl">|                  |
</span></span><span class="line"><span class="cl">|                  |
</span></span><span class="line"><span class="cl">| Extended Memory  |
</span></span><span class="line"><span class="cl">|                  |
</span></span><span class="line"><span class="cl">|                  |
</span></span><span class="line"><span class="cl">+------------------+  &lt;- 0x00100000 (1MB)
</span></span><span class="line"><span class="cl">|     BIOS ROM     |   64KB
</span></span><span class="line"><span class="cl">+------------------+  &lt;- 0x000F0000 (960KB)
</span></span><span class="line"><span class="cl">|  16-bit devices, |
</span></span><span class="line"><span class="cl">|  expansion ROMs  |
</span></span><span class="line"><span class="cl">+------------------+  &lt;- 0x000C0000 (768KB)
</span></span><span class="line"><span class="cl">|   VGA Display    |    128KB
</span></span><span class="line"><span class="cl">+------------------+  &lt;- 0x000A0000 (640KB)
</span></span><span class="line"><span class="cl">|                  |
</span></span><span class="line"><span class="cl">|    Low Memory    |
</span></span><span class="line"><span class="cl">|                  |
</span></span><span class="line"><span class="cl">+------------------+  &lt;- 0x00000000
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了兼容性的考虑。PC在一开始是16位的。但是地址线却有20位。也就是能够寻址1MB的地址空间。其中640KB为低端内存。
这段内容非常重要，所以需要好好注意。Lab2内存分配的时候会用到这个。
除去低端的640KB。那么1MB还留下 <code>1024KB - 640KB = 384KB</code>。这<code>384KB</code>的范围就是
<code>0x000A0000 ~ 0x000FFFFF</code>。</p>
<p>其中BIOS占掉了顶端的<code>64KB</code>的内存。尽管后来内存从1MB前进到了16MB，后来又进展到了4GB。但是PC的内存布局还是没有改变。主要是为了兼容性考虑。因此，32位的CPU在这里还是会有个洞。<code>0x000A0000 〜 0x00100000</code>。</p>
<p>原本低端内存可以连续的1MB，变成了两段</p>
<ul>
<li>0~640KB，</li>
<li>然后1MB〜更高的内存。</li>
</ul>
<p>即</p>
<ul>
<li>“conventional memory” (the first 640KB)</li>
<li>“extended memory” 1MB以上</li>
</ul>
<p>最新的x86架构可以支持4GB以上的物理内存了。所以RAM也可以扩展到0xFFFFFFFF以上的地址。在这种情况下BIOS需要设置第二个洞。也就是在32位地址的顶端。但是JOS目前来说，只是支持256MB的物理内存。所以这里设计时只考虑到了具有32位地址的地址空间的情况。</p>
<h3 id="the-rom-bios">The ROM BIOS</h3>
<p>接下来的操作里面，你会用到QEMU的debug功能来深入了解IA-32计算机的启动流程。
需要做以下事情：
打开两个termainal</p>
<p>一个窗口运行<code>make qemu-nox-gdb</code>
另外一个窗口运行<code>make gdb</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># make gdb
</span></span><span class="line"><span class="cl">GNU gdb (GDB) 6.8-debian
</span></span><span class="line"><span class="cl">Copyright (C) 2008 Free Software Foundation, Inc.
</span></span><span class="line"><span class="cl">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
</span></span><span class="line"><span class="cl">This is free software: you are free to change and redistribute it.
</span></span><span class="line"><span class="cl">There is NO WARRANTY, to the extent permitted by law.  Type &#34;show copying&#34;
</span></span><span class="line"><span class="cl">and &#34;show warranty&#34; for details.
</span></span><span class="line"><span class="cl">This GDB was configured as &#34;i486-linux-gnu&#34;.
</span></span><span class="line"><span class="cl">+ target remote localhost:26000
</span></span><span class="line"><span class="cl">The target architecture is assumed to be i8086
</span></span><span class="line"><span class="cl">[f000:fff0] 0xffff0:    ljmp   $0xf000,$0xe05b
</span></span><span class="line"><span class="cl">0x0000fff0 in ?? ()
</span></span><span class="line"><span class="cl">+ symbol-file obj/kern/kernel
</span></span><span class="line"><span class="cl">(gdb)
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里能够通过gdb一下子就连接上来，这是因为提供了一个<code>.gdbinit</code>文件，能够自动地attach到想要调试的程序上来。当然前提是已经把这个debug的程序运行起来的情况。</p>
<p>PC中BIOS大小为64k, 物理地址范围0x000f0000-0x000fffff
PC 开机首先0xfffff0处执行 <code>jmp [0xf000,0xe05b]</code> 指令。在gdb中使用<code>si(Step Instruction)</code>进行跟踪。第一条要执行的指令就是<code>ljmp</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[f000:fff0] 0xffff0:    ljmp   $0xf000,$0xe05b
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">si</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nl">f000</span><span class="p">:</span><span class="n">e05b</span><span class="p">]</span>    <span class="mh">0xfe05b</span><span class="o">:</span>    <span class="n">cmpw</span>   <span class="err">$</span><span class="mh">0xffc8</span><span class="p">,</span><span class="o">%</span><span class="nl">cs</span><span class="p">:(</span><span class="o">%</span><span class="n">esi</span><span class="p">)</span>   <span class="err">#</span> <span class="err">比较大小，改变</span><span class="n">PSW</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x0000e05b</span> <span class="n">in</span> <span class="o">??</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">si</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nl">f000</span><span class="p">:</span><span class="n">e062</span><span class="p">]</span>    <span class="mh">0xfe062</span><span class="o">:</span>    <span class="n">jne</span>    <span class="mh">0xd241d416</span>           <span class="err">#</span> <span class="err">不相等则跳转</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x0000e062</span> <span class="n">in</span> <span class="o">??</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">si</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nl">f000</span><span class="p">:</span><span class="n">e066</span><span class="p">]</span>    <span class="mh">0xfe066</span><span class="o">:</span>    <span class="n">xor</span>    <span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span>            <span class="err">#</span> <span class="err">清零</span><span class="n">edx</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x0000e066</span> <span class="n">in</span> <span class="o">??</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">si</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nl">f000</span><span class="p">:</span><span class="n">e068</span><span class="p">]</span>    <span class="mh">0xfe068</span><span class="o">:</span>    <span class="n">mov</span>    <span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">ss</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x0000e068</span> <span class="n">in</span> <span class="o">??</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">si</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nl">f000</span><span class="p">:</span><span class="n">e06a</span><span class="p">]</span>    <span class="mh">0xfe06a</span><span class="o">:</span>    <span class="n">mov</span>    <span class="err">$</span><span class="mh">0x7000</span><span class="p">,</span><span class="o">%</span><span class="n">sp</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x0000e06a</span> <span class="n">in</span> <span class="o">??</span> <span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从这个要执行的指令可以看出来。</p>
<p>IBM PC开始执行的物理位置是<code>0x000ffff0</code>。这个是位于1MB里面的很高的地址。也就是ROM BIOS最顶上<code>64KB</code>的顶部。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[f000:fff0]可以看出来，此时CS = 0xf000 and IP = 0xfff0.
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果执行完这条指令之后 <code>CS = 0xf000 and IP = 0xe05b</code>.
为什么QEMU一开始执行的时候是这样的？这是因为8088的芯片就是这样的。
在IBM最原始的PC就是这么使用的。总之一句话，当PC上电之后。CS:IP两个寄存器就强制被设置为这个值。<code>CS = 0xf000 and IP = 0xfff0</code>。</p>
<p>注意16位的寻址模式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">: physical address = 16 * segment + offset. 
</span></span><span class="line"><span class="cl">16 * 0xf000 + 0xfff0   # in hex multiplication by 16 is
</span></span><span class="line"><span class="cl">   = 0xf0000 + 0xfff0     # easy--just append a 0.
</span></span><span class="line"><span class="cl">   = 0xffff0
</span></span></code></pre></td></tr></table>
</div>
</div><p>1MB尾巴上的地址就是<code>0xffff0 + 16bytes</code>。除了放个ljmp之外，你也不要指望16bytes能做啥了。</p>
<p>当 BIOS 运行时，它会建立一个中断描述符表并初始化各种设备，例如 VGA 显示器。这就是您在 QEMU 窗口中看到的 “ <code>Starting SeaBIOS ”消息的来源。</code></p>
<p>初始化 PCI 总线和 BIOS 知道的所有重要设备后，它会搜索可引导设备，如软盘、硬盘或 CD-ROM。最终，当它找到可引导磁盘时，BIOS从磁盘 读取<em>引导加载程序并将控制权转移给它。</em></p>
<h2 id="part2-the-bootloader">Part2 The BootLoader</h2>
<p>软盘和磁盘一般都是被切分为512 byte区域，也就是扇区。一个扇区是一个块设备的最小传输单位。每次读写都是必须是扇区的整数倍。
如果这个软盘或者磁盘是可启动的。那么第一个扇区被叫做可启动扇区。这里也存放的就是可启动的代码。当BIOS找到这个扇区的时候，就把这512 byte读到0x7c00至0x7cff。然后用一个跳转指令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ljmp 0x07c0:0000
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于CD-ROM的支持，需要看 “El Torito” Bootable CD-ROM Format Specification.
对于6.828来说，由于完全是使用硬盘来启动的。所以在硬盘的开始必须是boot loader，并且这个boot loader必须是512 bytes大小。
这个boot loader主要是由两个文件构成</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">boot/boot.S
</span></span><span class="line"><span class="cl">boot/main.c
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里需要好好地读一下这个文件。然后知道这两个文件做了些啥。
boot loader把模式切到了32位保护模式。因为只有在这种模式下软件才可以访问1MB+以上的内存空间。保护模式在<code>1.2.7</code> and <code>1.2.8</code> of <code>PC Assembly Language</code> 进行了介绍。 <code>Intel architecture manuals</code>也对这个有详细介绍。</p>
<p>在16位模式下只需要考虑段地址。
其次，需要注意的是<code>boot loader</code>读了kernel。从硬盘到内存。在操作的时候走的是PC的寄存器操作。如果想要了解更多，可以读一下<code>&quot;IDE hard drive controller&quot;</code> in <code>the 6.828 reference page</code>.的这一部分。</p>
<p>当你理解了<code>boot loader</code>的源码之后。接下来可以看一下<code>obj/boot/boot.asm</code>。b *0x7c00<code>就可以把断点设置在</code>0x7c00`。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">b *0x7c00 # 设置断点在0x7c00
</span></span><span class="line"><span class="cl">si 表示单步执行
</span></span><span class="line"><span class="cl">si 2 表示接着执行两条指令
</span></span><span class="line"><span class="cl">c 表示不再单步执行。直接开始运行了
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看内存中的指令，有时候可能需要查看内存操作的结果。这个时候需要用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">x/i 调试命令
</span></span><span class="line"><span class="cl">x/Ni 基中N是指令的数目; 会把指定内存里面的指令翻译成汇编。
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="实模式和保护模式">实模式和保护模式</h3>
<p>实模式和保护模式都是CPU的工作模式，而CPU的工作模式是指CPU的寻址方式、寄存器大小等用来反应CPU在该环境下如何工作的概念。</p>
<p>1.实模式工作原理</p>
<p>实模式出现于早期8088CPU时期。当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：</p>
<p>　　(段基址：段偏移量)</p>
<p>　 其中第一个字段是段基址，它的值是由<strong>段寄存器</strong>提供的(一般来说，段寄存器有6种，分别为cs，ds，ss，es，fs，gs，这几种段寄存器都有自己的特殊意义，这里不做介绍)。</p>
<p>　 第二字段是段内偏移量，代表你要访问的这个内存地址距离这个段基址的偏移。它的值就是由通用寄存器来提供的，所以也是16位。那么两个16位的值如何组合成一个20位的地址呢？CPU采用的方式是把段寄存器所提供的段基址先向左移4位。这样就变成了一个20位的值，然后再与段偏移量相加。</p>
<p>即：</p>
<p>　　物理地址 = 段基址&laquo;4 + 段内偏移</p>
<p>　　所以假设段寄存器中的值是0xff00，段偏移量为0x0110。则这个地址对应的真实物理地址是 0xff00&laquo;4 + 0x0110 = 0xff110。</p>
<p>由上面的介绍可见，实模式的&quot;实&quot;更多地体现在其地址是真实的物理地址。</p>
<p>2.保护模式工作原理</p>
<p>随着CPU的发展，CPU的地址线的个数也从原来的20根变为现在的32根，所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位。所以实模式下的内存地址计算方式就已经不再适合了。所以就引入了现在的保护模式，实现更大空间的，更灵活也<strong>更安全</strong>的内存访问。</p>
<p>在保护模式下，CPU的32条地址线全部有效，可寻址高达4G字节的物理地址空间; 但是我们的内存寻址方式还是得兼容老办法(这也是没办法的，有时候是为了方便，有时候是一种无奈)，即(段基址：段偏移量)的表示方式。当然此时CPU中的通用寄存器都要换成32位寄存器(除了段寄存器，原因后面再说)来保证寄存器能访问所有的4GB空间。</p>
<p>我们的偏移值和实模式下是一样的，就是变成了32位而已，而段值仍旧是存放在原来16位的段寄存器中，<strong>但是这些段寄存器存放的却不再是段基址了</strong>，毕竟之前说过实模式下寻址方式不安全，我们在保护模式下需要加一些限制，而这些限制可不是一个寄存器能够容纳的，于是我们把这些关于内存段的限制信息放在一个叫做<strong>全局描述符表(GDT)<strong>的结构里。全局描述符表中含有一个个表项，每一个表项称为</strong>段描述符。<strong>而段寄存器在保护模式下存放的便是相当于一个数组索引的东西，通过这个索引，可以找到对应的表项。段描述符存放了段基址、段界限、内存段类型属性(比如是数据段还是代码段,注意</strong>一个段描述符只能用来定义一个内存段</strong>)等许多属性,具体信息见下图：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111104.jpeg"
        data-srcset="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111104.jpeg, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111104.jpeg 1.5x, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111104.jpeg 2x"
        data-sizes="auto"
        alt="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111104.jpeg"
        title="img" /></p>
<p>其中，段界限表示段边界的扩张最值，即最大扩展多少或最小扩展多少，用20位来表示，它的单位可以是字节，也可以是4KB，这是由G位决定的(G为1时表示单位为4KB)。</p>
<p>实际段界限边界值=(描述符中的段界限+1)*（段界限的单位大小(即字节或4KB))-1，如果偏移地址超过了段界限，CPU会抛出异常。</p>
<p>全局描述符表位于内存中，需要用专门的寄存器指向它后， CPU 才知道它在哪里。这个专门的寄存器便是<strong>GDTR</strong>(一个48位的寄存器),专门用来存储 GDT 的内存地址及大小。</p>
<h3 id="bootsmainc">Boot.S&amp;main.c</h3>
<p>设置一个断点在地址0x7c00处，这是boot sector被加载的位置。然后让程序继续运行直到这个断点。跟踪/boot/boot.S文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件obj/boot/boot.asm。你也可以使用GDB的x/i指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。</p>
<p>追踪到bootmain函数中，而且还要具体追踪到readsect()子函数里面。找出和readsect()c语言程序的每一条语句所对应的汇编指令，回到bootmain()，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p>
<p>　答：</p>
<p>　　下面我们将分别分析一下这道练习中所涉及到的两个重要文件，它们一起组成了boot loader。分别是**/boot/boot.S<strong>和</strong>/boot/main.c**文件。其中前者是一个汇编文件，后者是一个C语言文件。当BIOS运行完成之后，CPU的控制权就会转移到boot.S文件上。所以我们首先看一下boot.S文件。</p>
<p>　　<strong>/boot/boot.S：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1 .globl start
</span></span><span class="line"><span class="cl">2 start:
</span></span><span class="line"><span class="cl">3   .code16                # Assemble for 16-bit mode
</span></span><span class="line"><span class="cl">4   cli                    # Disable interrupts
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　这几条指令就是boot.S最开始的几句，其中cli是boot.S，也是boot loader的第一条指令。这条指令用于把所有的中断都关闭。因为在BIOS运行期间有可能打开了中断。此时CPU工作在实模式下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">5  cld                         # String operations increment
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　这条指令用于指定之后发生的串处理操作的指针移动方向。在这里现在对它大致了解就够了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">6  # Set up the important data segment registers (DS, ES, SS).
</span></span><span class="line"><span class="cl">7  xorw    %ax,%ax             # Segment number zero
</span></span><span class="line"><span class="cl">8  movw    %ax,%ds             # -&gt; Data Segment
</span></span><span class="line"><span class="cl">9  movw    %ax,%es             # -&gt; Extra Segment
</span></span><span class="line"><span class="cl">10 movw    %ax,%ss             # -&gt; Stack Segment
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　这几条命令主要是在把三个段寄存器，ds，es，ss全部清零，因为经历了BIOS，操作系统不能保证这三个寄存器中存放的是什么数。所以这也是为后面进入保护模式做准备。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">11  # Enable A20:
</span></span><span class="line"><span class="cl">12  #   For backwards compatibility with the earliest PCs, physical
</span></span><span class="line"><span class="cl">13  #   address line 20 is tied low, so that addresses higher than
</span></span><span class="line"><span class="cl">14  #   1MB wrap around to zero by default.  This code undoes this.
</span></span><span class="line"><span class="cl">15 seta20.1:
</span></span><span class="line"><span class="cl">16  inb     $0x64,%al               # Wait for not busy
</span></span><span class="line"><span class="cl">17  testb   $0x2,%al
</span></span><span class="line"><span class="cl">18  jnz     seta20.1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">19  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64
</span></span><span class="line"><span class="cl">20  outb    %al,$0x64
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">21 seta20.2:
</span></span><span class="line"><span class="cl">22  inb     $0x64,%al               # Wait for not busy
</span></span><span class="line"><span class="cl">23  testb   $0x2,%al
</span></span><span class="line"><span class="cl">24  jnz     seta20.2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">25  movb    $0xdf,%al               # 0xdf -&gt; port 0x60
</span></span><span class="line"><span class="cl">26  outb    %al,$0x60
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　这部分指令就是在准备把CPU的工作模式从实模式转换为保护模式。我们可以看到其中的指令包括inb，outb这样的IO端口命令。所以这些指令都是在对外部设备进行操作。根据下面的链接：</p>
<p>　　 <a href="http://bochs.sourceforge.net/techspec/PORTS.LST" target="_blank" rel="noopener noreffer ">http://bochs.sourceforge.net/techspec/PORTS.LST</a></p>
<p>　　我们可以查看到，0x64端口属于键盘控制器804x，名称是控制器读取状态寄存器。下面是它各个位的含义。</p>
<p>　　<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111273.jpeg"
        data-srcset="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111273.jpeg, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111273.jpeg 1.5x, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111273.jpeg 2x"
        data-sizes="auto"
        alt="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111273.jpeg"
        title="img" /></p>
<p>　　所以16~18号指令是在不断的检测bit1。bit1的值代表输入缓冲区是否满了，也就是说CPU传送给控制器的数据，控制器是否已经取走了，如果CPU想向控制器传送新的数据的话，必须先保证这一位为0。所以这三条指令会一直等待这一位变为0，才能继续向后运行。</p>
<p>　　当0x64端口准备好读入数据后，现在就可以写入数据了，所以19~20这两条指令是把0xd1这条数据写入到0x64端口中。当向0x64端口写入数据时，则代表向键盘控制器804x发送指令。这个指令将会被送给0x60端口。</p>
<p>　　<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224333.jpg"
        data-srcset="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224333.jpg, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224333.jpg 1.5x, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224333.jpg 2x"
        data-sizes="auto"
        alt="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224333.jpg"
        title="img" /></p>
<p>　　通过图中可见，D1指令代表下一次写入0x60端口的数据将被写入给804x控制器的输出端口。可以理解为下一个写入0x60端口的数据是一个控制指令。</p>
<p>　　然后21~24号指令又开始再次等待，等待刚刚写入的指令D1，是否已经被读取了。</p>
<p>　　如果指令被读取了，25~26号指令会向控制器输入新的指令，0xdf。通过查询我们看到0xDF指令的含义如下</p>
<p>　　<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224257.jpg"
        data-srcset="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224257.jpg, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224257.jpg 1.5x, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224257.jpg 2x"
        data-sizes="auto"
        alt="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224257.jpg"
        title="img" /></p>
<p>　　这个指令的含义可以从图中看到，使能A20线，==代表可以进入保护模式==了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">27   # Switch from real to protected mode, using a bootstrap GDT
</span></span><span class="line"><span class="cl">28   # and segment translation that makes virtual addresses 
</span></span><span class="line"><span class="cl">29   # identical to their physical addresses, so that the 
</span></span><span class="line"><span class="cl">30   # effective memory map does not change during the switch.
</span></span><span class="line"><span class="cl">31   lgdt    gdtdesc
</span></span><span class="line"><span class="cl">32   movl    %cr0, %eax
</span></span><span class="line"><span class="cl">33   orl     $CR0_PE_ON, %eax
</span></span><span class="line"><span class="cl">34   movl    %eax, %cr0
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　首先31号指令 lgdt gdtdesc，是把gdtdesc这个标识符的值送入全局映射描述符表寄存器GDTR中。这个GDT表是处理器工作于保护模式下一个非常重要的表。具体可以参照我们的Appendix 1关于实模式和保护模式的介绍。至于这条指令的功能就是把关于GDT表的一些重要信息存放到CPU的GDTR寄存器中，其中包括GDT表的内存起始地址，以及GDT表的长度。这个寄存器由48位组成，其中低16位表示该表长度，高32位表该表在内存中的起始地址。所以gdtdesc是一个标识符，标识着一个内存地址。从这个内存地址开始之后的6个字节中存放着GDT表的长度和起始地址。我们可以在这个文件的末尾看到gdtdesc，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> 1 # Bootstrap GDT
</span></span><span class="line"><span class="cl"> 2 .p2align 2                               # force 4 byte alignment
</span></span><span class="line"><span class="cl"> 3 gdt:
</span></span><span class="line"><span class="cl"> 4   SEG_NULL                               # null seg
</span></span><span class="line"><span class="cl"> 5   SEG(STA_X|STA_R, 0x0, 0xffffffff)      # code seg
</span></span><span class="line"><span class="cl"> 6   SEG(STA_W, 0x0, 0xffffffff)            # data seg
</span></span><span class="line"><span class="cl"> 7 
</span></span><span class="line"><span class="cl"> 8 gdtdesc:
</span></span><span class="line"><span class="cl"> 9   .word   0x17                           # sizeof(gdt) - 1
</span></span><span class="line"><span class="cl">10   .long   gdt                            # address gdt
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　其中第3行的gdt是一个标识符，标识从这里开始就是GDT表了。可见这个GDT表中包括三个表项(4,5,6行)，分别代表三个段，null seg，code seg，data seg。由于xv6其实并没有使用分段机制，也就是说数据和代码都是写在一起的，所以数据段和代码段的起始地址都是0x0，大小都是0xffffffff=4GB。</p>
<p>　　在第4~6行是调用SEG()子程序来构造GDT表项的。这个子函数定义在mmu.h中，形式如下：　　</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">　#define SEG(type,base,lim)                    \
</span></span><span class="line"><span class="cl">                    .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);    \
</span></span><span class="line"><span class="cl">                    .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),        \
</span></span><span class="line"><span class="cl">                    (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　可见函数需要3个参数，一是type即这个段的访问权限，二是base，这个段的起始地址，三是lim，即这个段的大小界限。gdt表中的每一个表项的结构如图所示：</p>
<p>　　<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224651.jpg"
        data-srcset="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224651.jpg, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224651.jpg 1.5x, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224651.jpg 2x"
        data-sizes="auto"
        alt="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202305082224651.jpg"
        title="img" /></p>
<p>　　 每个表项一共8字节，其中limit_low就是limit的低16位。base_low就是base的低16位，依次类推，所以我们就可以理解SEG函数为什么要那么写（其实还是有很多不理解的。。）。</p>
<p>　　 然后在gdtdesc处就要存放这个GDT表的信息了，其中0x17是这个表的大小-1 = 0x17 = 23，至于为什么不直接存表的大小24，根据查询是官方规定的。紧接着就是这个表的起始地址gdt。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">27   # Switch from real to protected mode, using a bootstrap GDT
</span></span><span class="line"><span class="cl">28   # and segment translation that makes virtual addresses 
</span></span><span class="line"><span class="cl">29   # identical to their physical addresses, so that the 
</span></span><span class="line"><span class="cl">30   # effective memory map does not change during the switch.
</span></span><span class="line"><span class="cl">31   lgdt    gdtdesc
</span></span><span class="line"><span class="cl">32   movl    %cr0, %eax
</span></span><span class="line"><span class="cl">33   orl     $CR0_PE_ON, %eax
</span></span><span class="line"><span class="cl">34   movl    %eax, %cr0
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　再回到刚才那里，当加载完GDT表的信息到GDTR寄存器之后。紧跟着3个操作，32~34指令。 这几步操作明显是在修改CR0寄存器的内容。CR0寄存器还有CR1~CR3寄存器都是80x86的控制寄存器。其中$CR0_PE的值定义于&quot;mmu.h&quot;文件中，为0x00000001。可见上面的操作是把CR0寄存器的bit0置1，CR0寄存器的bit0是保护模式启动位，把这一位值1代表==保护模式启动==。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">35  ljmp    $PROT_MODE_CSEG, $protcseg
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　这只是一个简单的跳转指令，这条指令的目的在于把当前的运行模式切换成32位地址模式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protcseg:
</span></span><span class="line"><span class="cl">  # Set up the protected-mode data segment registers
</span></span><span class="line"><span class="cl">36  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector
</span></span><span class="line"><span class="cl">37  movw    %ax, %ds                # -&gt; DS: Data Segment
</span></span><span class="line"><span class="cl">38  movw    %ax, %es                # -&gt; ES: Extra Segment
</span></span><span class="line"><span class="cl">39  movw    %ax, %fs                # -&gt; FS
</span></span><span class="line"><span class="cl">40  movw    %ax, %gs                # -&gt; GS
</span></span><span class="line"><span class="cl">41  movw    %ax, %ss                # -&gt; SS: Stack Segment
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　  修改这些寄存器的值。这些寄存器都是段寄存器。大家可以戳这个链接看一下具体介绍 <a href="http://www.eecg.toronto.edu/~amza/[www.mindsec.com/files/x86regs.html]%28http://www.mindsec.com/files/x86regs.html%29" target="_blank" rel="noopener noreffer ">http://www.eecg.toronto.edu/~amza/[www.mindsec.com/files/x86regs.html](http://www.mindsec.com/files/x86regs.html)</a></p>
<p>　　 这里的23~29步之所以这么做是按照规定来的，https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table链接中指出，如果刚刚加载完GDTR寄存器我们必须要重新加载所有的段寄存器的值，而其中CS段寄存器必须通过长跳转指令，即23号指令来进行加载。所以这些步骤是在第19步完成后必须要做的。这样才能是GDTR的值生效。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># Set up the stack pointer and call into C.
</span></span><span class="line"><span class="cl">42  movl    $start, %esp
</span></span><span class="line"><span class="cl">43  call bootmain
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　接下来的指令就是要设置当前的esp寄存器的值，然后准备正式跳转到main.c文件中的bootmain函数处。我们接下来分析一下这个函数的每一条指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// read 1st page off disk
</span></span><span class="line"><span class="cl">1 readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);
</span></span></code></pre></td></tr></table>
</div>
</div><p>　 这里面调用了一个函数readseg，这个函数在bootmain之后被定义了：</p>
<p>void readseg(uchar <em>pa, uint count, uint offset);</em>*
**</p>
<p>　 它的功能从注释上来理解应该是，把距离内核起始地址offset个偏移量存储单元作为起始，将它和它之后的count字节的数据读出送入以pa为起始地址的内存物理地址处。</p>
<p>　 所以这条指令是把内核的第一个页(4MB = 4096 = SECTSIZE<em>8 = 512</em>8)的内容读取的内存地址ELFHDR(0x10000)处。其实完成这些后相当于把操作系统映像文件的elf头部读取出来放入内存中。</p>
<p>　 读取完这个内核的elf头部信息后，需要对这个elf头部信息进行验证，并且也需要通过它获取一些重要信息。所以有必要了解下elf头部。</p>
<hr>
<p>　 注： <a href="http://wiki.osdev.org/ELF" target="_blank" rel="noopener noreffer ">http://wiki.osdev.org/ELF</a></p>
<p>elf文件：elf是一种文件格式，主要被用来把程序存放到磁盘上。是在程序被编译和链接后被创建出来的。一个elf文件包括多个段。对于一个可执行程序，通常包含存放代码的文本段(text section)，存放全局变量的data段，存放字符串常量的rodata段。elf文件的头部就是用来描述这个elf文件如何在存储器中存储。</p>
<p>需要注意的是，你的文件是可链接文件还是可执行文件，会有不同的elf头部格式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">2 if (ELFHDR-&gt;e_magic != ELF_MAGIC)
</span></span><span class="line"><span class="cl">3        goto bad;
</span></span></code></pre></td></tr></table>
</div>
</div><p>　 elf头部信息的magic字段是整个头部信息的开端。并且如果这个文件是格式是ELF格式的话，文件的elf-&gt;magic域应该是=ELF_MAGIC的，所以这条语句就是判断这个输入文件是否是合法的elf可执行文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">4 ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);
</span></span></code></pre></td></tr></table>
</div>
</div><p>　 我们知道头部中一定包含Program Header Table。这个表格存放着程序中所有段的信息。通过这个表我们才能找到要执行的代码段，数据段等等。所以我们要先获得这个表。</p>
<p>　 这条指令就可以完成这一点，首先elf是表头起址，而phoff字段代表Program Header Table距离表头的偏移量。所以ph可以被指定为Program Header Table表头。</p>
<p>　</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">5 eph = ph + ELFHDR-&gt;e_phnum;
</span></span></code></pre></td></tr></table>
</div>
</div><p>　 由于phnum中存放的是Program Header Table表中表项的个数，即段的个数。所以这步操作是吧eph指向该表末尾。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">6</span> <span class="k">for</span> <span class="p">(;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">eph</span><span class="p">;</span> <span class="n">ph</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// p_pa is the load address of this segment (as well
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// as the physical address)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">7</span>    <span class="nf">readseg</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_pa</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>　 这个for循环就是在加载所有的段到内存中。ph-&gt;paddr根据参考文献中的说法指的是这个段在内存中的物理地址。ph-&gt;off字段指的是这一段的开头相对于这个elf文件的开头的偏移量。ph-&gt;filesz字段指的是这个段在elf文件中的大小。ph-&gt;memsz则指的是这个段被实际装入内存后的大小。通常来说memsz一定大于等于filesz，因为段在文件中时许多未定义的变量并没有分配空间给它们。</p>
<p>　  所以这个循环就是在把操作系统内核的各个段从外存读入内存中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">8 ((void (*)(void)) (ELFHDR-&gt;e_entry))();
</span></span></code></pre></td></tr></table>
</div>
</div><p>　 e_entry字段指向的是这个文件的执行入口地址。所以这里相当于开始运行这个文件。也就是内核文件。 自此就把控制权从boot loader转交给了操作系统的内核。</p>
<h3 id="exercise3">exercise3</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Q：处理器什么时候开始执行 32 位代码？究竟是什么导致从 16 位模式切换到 32 位模式？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">A：movl    %eax, %cr0
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果指令被读取了，25~26号指令会向控制器输入新的指令，0xdf。通过查询我们看到0xDF指令的含义如下</p>
<p>　　<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../../../study/6.828/lab1.assets/809277-20160108222031012-642740036.jpg"
        data-srcset="../../../../study/6.828/lab1.assets/809277-20160108222031012-642740036.jpg, ../../../../study/6.828/lab1.assets/809277-20160108222031012-642740036.jpg 1.5x, ../../../../study/6.828/lab1.assets/809277-20160108222031012-642740036.jpg 2x"
        data-sizes="auto"
        alt="../../../../study/6.828/lab1.assets/809277-20160108222031012-642740036.jpg"
        title="img" /></p>
<p>这个指令的含义可以从图中看到，使能A20线，==代表可以进入保护模式==了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">movb    $0xdf,%al               # 0xdf -&gt; port 0x60
</span></span><span class="line"><span class="cl">outb    %al,$0x60
</span></span></code></pre></td></tr></table>
</div>
</div><p>31指令当加载完GDT表的信息到GDTR寄存器之后。紧跟着3个操作，32~34指令。 这几步操作明显是在修改CR0寄存器的内容。CR0寄存器还有CR1~CR3寄存器都是80x86的控制寄存器。其中$CR0_PE的值定义于&quot;mmu.h&quot;文件中，为0x00000001。可见上面的操作是把CR0寄存器的bit0置1，CR0寄存器的bit0是保护模式启动位，把这一位值1代表==保护模式启动==。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">27   # Switch from real to protected mode, using a bootstrap GDT
</span></span><span class="line"><span class="cl">28   # and segment translation that makes virtual addresses 
</span></span><span class="line"><span class="cl">29   # identical to their physical addresses, so that the 
</span></span><span class="line"><span class="cl">30   # effective memory map does not change during the switch.
</span></span><span class="line"><span class="cl">31   lgdt    gdtdesc
</span></span><span class="line"><span class="cl">32   movl    %cr0, %eax
</span></span><span class="line"><span class="cl">33   orl     $CR0_PE_ON, %eax
</span></span><span class="line"><span class="cl">34   movl    %eax, %cr0
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">Q</span><span class="err">：引导加载程序执行的最后一条指令</span> <span class="err">是什么，它刚刚加载的内核的第一条指令是什么？</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="err">：</span><span class="p">((</span><span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">void</span><span class="p">))</span> <span class="p">(</span><span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">))();</span>
</span></span><span class="line"><span class="cl"><span class="err">自此</span><span class="n">bootloader就把控制权转交给了OS</span><span class="err">。查看</span><span class="n">boot</span><span class="o">.</span><span class="n">asm文件找到bootloader</span><span class="err">，</span>	
</span></span><span class="line"><span class="cl"><span class="p">((</span><span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">void</span><span class="p">))</span> <span class="p">(</span><span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">))();</span>
</span></span><span class="line"><span class="cl">    <span class="mi">7</span><span class="n">d81</span><span class="p">:</span>	<span class="n">ff</span> <span class="mi">15</span> <span class="mi">18</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">00</span>    	<span class="n">call</span>   <span class="o">*</span><span class="mh">0x10018</span>
</span></span><span class="line"><span class="cl"><span class="err">随后通过在</span><span class="n">gdb中输入b</span> <span class="o">*</span><span class="mh">0x7d81</span><span class="err">在</span><span class="mh">0x7d81</span><span class="err">处打上断点，随后</span><span class="n">c再si</span><span class="err">，查看加载内核的第一条指令。</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x10000c</span><span class="p">:</span>    <span class="n">movw</span>   <span class="o">$</span><span class="mh">0x1234</span><span class="p">,</span><span class="mh">0x472</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Q：内核的第一条指令在哪里？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">A：0x10000c:    movw   $0x1234,0x472   第一条指令在0x10000c处。
</span></span><span class="line"><span class="cl">也可以通过objdump -f obj/kern/kernel查看
</span></span><span class="line"><span class="cl">obj/kern/kernel:     file format elf32-i386
</span></span><span class="line"><span class="cl">architecture: i386, flags 0x00000112:
</span></span><span class="line"><span class="cl">EXEC_P, HAS_SYMS, D_PAGED
</span></span><span class="line"><span class="cl">start address 0x0010000c
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Q：引导加载程序如何决定它必须读取多少个扇区才能从磁盘中获取整个内核？它在哪里找到这些信息？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">A：详细的将涉及到ELF格式，从ELF头部中获取到这部分信息
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">4 ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);
</span></span></code></pre></td></tr></table>
</div>
</div><p>　 我们知道头部中一定包含Program Header Table。这个表格存放着程序中所有段的信息。通过这个表我们才能找到要执行的代码段，数据段等等。所以我们要先获得这个表。</p>
<p>　 这条指令就可以完成这一点，首先elf是表头起址，而phoff字段代表Program Header Table距离表头的偏移量。所以ph可以被指定为Program Header Table表头。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">5 eph = ph + ELFHDR-&gt;e_phnum;
</span></span></code></pre></td></tr></table>
</div>
</div><p>　 由于phnum中存放的是Program Header Table表中表项的个数，即段的个数。所以这步操作是吧eph指向该表末尾。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="mi">6</span> <span class="k">for</span> <span class="p">(;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">eph</span><span class="p">;</span> <span class="n">ph</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">p_pa</span> <span class="n">is</span> <span class="n">the</span> <span class="nb">load</span> <span class="n">address</span> <span class="n">of</span> <span class="n">this</span> <span class="n">segment</span> <span class="p">(</span><span class="n">as</span> <span class="n">well</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">as</span> <span class="n">the</span> <span class="n">physical</span> <span class="n">address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">7</span>    <span class="n">readseg</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_pa</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>　 这个for循环就是在加载所有的段到内存中。ph-&gt;paddr根据参考文献中的说法指的是这个段在内存中的物理地址。ph-&gt;off字段指的是这一段的开头相对于这个elf文件的开头的偏移量。ph-&gt;filesz字段指的是这个段在elf文件中的大小。ph-&gt;memsz则指的是这个段被实际装入内存后的大小。通常来说memsz一定大于等于filesz，因为段在文件中时许多未定义的变量并没有分配空间给它们。</p>
<p>　  所以这个循环就是在把操作系统内核的各个段从外存读入内存中。</p>
<h3 id="loading-the-kernel">Loading the kernel</h3>
<h3 id="exercise4">exercise4</h3>
<p>ELF程序文是由一个固定长度的ELF头开始的。紧接着的是一个动态可变的程序头list。每个程序头，指明了每个程序段需要被加载的位置，长度，相对于整个程序的偏移量。</p>
<p>程序头list</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">Proghdr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">p_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">p_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">p_va</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">p_pa</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">p_filesz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">p_memsz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">p_flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">p_align</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>注意：相对的是整个程序头的偏移量，而不是相对于磁盘头的偏移量</strong></p>
<p>由于在编译完成之后，才会把kernel写入磁盘的某个扇区。在编译的时候是无法知道会被写入到哪个扇区的。所以编译的时候只能说把相对的位置写入到ELF里面。
这些各种程序头比较常见的有以下几个：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">.</span><span class="n">text</span><span class="p">:</span> <span class="n">The</span> <span class="n">program</span><span class="s1">&#39;s executable instructions.</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">rodata</span><span class="p">:</span> <span class="n">Read</span><span class="o">-</span><span class="n">only</span> <span class="n">data</span><span class="p">,</span> <span class="n">such</span> <span class="n">as</span> <span class="n">ASCII</span> <span class="n">string</span> <span class="n">constants</span> <span class="n">produced</span> <span class="n">by</span> <span class="n">the</span> <span class="n">C</span> <span class="n">compiler</span><span class="o">.</span> <span class="p">(</span><span class="n">We</span> <span class="n">will</span> <span class="ow">not</span> <span class="n">bother</span> <span class="n">setting</span> <span class="n">up</span> <span class="n">the</span> <span class="n">hardware</span> <span class="n">to</span> <span class="n">prohibit</span> <span class="n">writing</span><span class="p">,</span> <span class="n">however</span><span class="o">.</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">data</span><span class="p">:</span> <span class="n">The</span> <span class="n">data</span> <span class="n">section</span> <span class="n">holds</span> <span class="n">the</span> <span class="n">program</span><span class="s1">&#39;s initialized data, such as global variables declared with initializers like int x = 5;.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当链接器在计算内存部局的时候，也会保留足够的空间给各种未初始化的全局变量（初始化为0）。一般而言这个空间被称之为.bss段。
由于全部都是被设置为0.所以也就没有必要记录这些内容在ELF里面。所以ELF文件里面只需要记住.bss在内存里面的起始位置，以及大小。然后加载方需要确保这些.bss在内存里面正确的设置。以及初始化为0。
可以通过如下命令来查看<code>obj/kern/kernel</code>里面的<code>names, sizes</code>, 以及各种链接地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ objdump -h obj/kern/kernel
</span></span><span class="line"><span class="cl">obj/kern/kernel:     file format elf32-i386
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Sections:
</span></span><span class="line"><span class="cl">Idx Name          Size      VMA       LMA       File off  Algn
</span></span><span class="line"><span class="cl">  0 .text         00001917  f0100000  00100000  00001000  2**4
</span></span><span class="line"><span class="cl">                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span></span><span class="line"><span class="cl">  1 .rodata       00000714  f0101920  00101920  00002920  2**5
</span></span><span class="line"><span class="cl">                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span></span><span class="line"><span class="cl">  2 .stab         00003889  f0102034  00102034  00003034  2**2
</span></span><span class="line"><span class="cl">                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span></span><span class="line"><span class="cl">  3 .stabstr      000018af  f01058bd  001058bd  000068bd  2**0
</span></span><span class="line"><span class="cl">                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span></span><span class="line"><span class="cl">  4 .data         0000a300  f0108000  00108000  00009000  2**12
</span></span><span class="line"><span class="cl">                  CONTENTS, ALLOC, LOAD, DATA
</span></span><span class="line"><span class="cl">  5 .bss          00000644  f0112300  00112300  00013300  2**5
</span></span><span class="line"><span class="cl">                  ALLOC
</span></span><span class="line"><span class="cl">  6 .comment      0000002b  00000000  00000000  00013300  2**0
</span></span><span class="line"><span class="cl">                  CONTENTS, READONLY
</span></span></code></pre></td></tr></table>
</div>
</div><p>真正要了解这个文件，需要查看链接设定文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">kern/kernel.ld
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过这个文件可以知道程序被加载的虚拟地址(VMA)，物理地址(LMA)分别是如何指定的。也可以通过File off查看相对文件的偏移量。这个File off偏移量是如何指定的？这个非常有意思。刚好在boot/main.c里面就是一开始就读了了8个扇区，也就是<code>0x1000 bytes</code>。</p>
<h4 id="elf文件格式简图">ELF文件格式简图</h4>
<p>kernel在编译和链接的时候，其虚拟地址与物理地址是不一样的。在加载的时候，也就相应地需要设置好页表。</p>
<p>但是考虑一下<code>boot loader</code>。在加载的时候，肯定是没有什么页表等着给你用的。<code>BIOS</code>可不会给你设置页表。所以</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">h</span> <span class="n">obj</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">boot</span><span class="o">.</span><span class="n">out</span>
</span></span><span class="line"><span class="cl"><span class="n">Sections</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="n">Idx</span> <span class="n">Name</span>          <span class="n">Size</span>      <span class="n">VMA</span>       <span class="n">LMA</span>       <span class="ne">File</span> <span class="n">off</span>  <span class="n">Algn</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 注意这里的VMA与LMA是完全一致的。这是由于被加载进BIOS的时候，没有页表与段表可用。</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># size = 380 bytes.</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 这里面就包含了boot loader所需要的所有信息。</span>
</span></span><span class="line"><span class="cl">  <span class="mi">0</span> <span class="o">.</span><span class="n">text</span>         <span class="mi">0000017</span><span class="n">c</span>  <span class="mi">00007</span><span class="n">c00</span>  <span class="mi">00007</span><span class="n">c00</span>  <span class="mi">00000074</span>  <span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">                  <span class="n">CONTENTS</span><span class="p">,</span> <span class="n">ALLOC</span><span class="p">,</span> <span class="n">LOAD</span><span class="p">,</span> <span class="n">CODE</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># size = 176这个段实际上是没有什么用的？</span>
</span></span><span class="line"><span class="cl">  <span class="mi">1</span> <span class="o">.</span><span class="n">eh_frame</span>     <span class="mi">000000</span><span class="n">b0</span>  <span class="mi">00007</span><span class="n">d7c</span>  <span class="mi">00007</span><span class="n">d7c</span>  <span class="mi">000001</span><span class="n">f0</span>  <span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">                  <span class="n">CONTENTS</span><span class="p">,</span> <span class="n">ALLOC</span><span class="p">,</span> <span class="n">LOAD</span><span class="p">,</span> <span class="n">READONLY</span><span class="p">,</span> <span class="n">DATA</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 接下来的三个段，里面都是用于DEBUG的。所以真实用的时候，不会被用到。</span>
</span></span><span class="line"><span class="cl">  <span class="mi">2</span> <span class="o">.</span><span class="n">stab</span>         <span class="mi">000007</span><span class="n">b0</span>  <span class="mi">00000000</span>  <span class="mi">00000000</span>  <span class="mi">000002</span><span class="n">a0</span>  <span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">                  <span class="n">CONTENTS</span><span class="p">,</span> <span class="n">READONLY</span><span class="p">,</span> <span class="n">DEBUGGING</span>
</span></span><span class="line"><span class="cl">  <span class="mi">3</span> <span class="o">.</span><span class="n">stabstr</span>      <span class="mi">00000846</span>  <span class="mi">00000000</span>  <span class="mi">00000000</span>  <span class="mi">00000</span><span class="n">a50</span>  <span class="mi">2</span><span class="o">**</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">                  <span class="n">CONTENTS</span><span class="p">,</span> <span class="n">READONLY</span><span class="p">,</span> <span class="n">DEBUGGING</span>
</span></span><span class="line"><span class="cl">  <span class="mi">4</span> <span class="o">.</span><span class="n">comment</span>      <span class="mi">0000002</span><span class="n">b</span>  <span class="mi">00000000</span>  <span class="mi">00000000</span>  <span class="mi">00001296</span>  <span class="mi">2</span><span class="o">**</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">                  <span class="n">CONTENTS</span><span class="p">,</span> <span class="n">READONLY</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">x</span> <span class="n">obj</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">boot</span><span class="o">.</span><span class="n">out</span>
</span></span><span class="line"><span class="cl"><span class="n">obj</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">boot</span><span class="o">.</span><span class="n">out</span><span class="p">:</span>     <span class="n">file</span> <span class="n">format</span> <span class="n">elf32</span><span class="o">-</span><span class="n">i386</span>
</span></span><span class="line"><span class="cl"><span class="n">obj</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">boot</span><span class="o">.</span><span class="n">out</span>
</span></span><span class="line"><span class="cl"><span class="n">architecture</span><span class="p">:</span> <span class="n">i386</span><span class="p">,</span> <span class="n">flags</span> <span class="mh">0x00000012</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="n">EXEC_P</span><span class="p">,</span> <span class="n">HAS_SYMS</span>
</span></span><span class="line"><span class="cl"><span class="n">start</span> <span class="n">address</span> <span class="mh">0x00007c00</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Program</span> <span class="n">Header</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOAD</span> <span class="n">off</span>    <span class="mh">0x00000074</span> <span class="n">vaddr</span> <span class="mh">0x00007c00</span> <span class="n">paddr</span> <span class="mh">0x00007c00</span> <span class="n">align</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">         <span class="n">filesz</span> <span class="mh">0x0000022c</span> <span class="n">memsz</span> <span class="mh">0x0000022c</span> <span class="n">flags</span> <span class="n">rwx</span>
</span></span><span class="line"><span class="cl">   <span class="n">STACK</span> <span class="n">off</span>    <span class="mh">0x00000000</span> <span class="n">vaddr</span> <span class="mh">0x00000000</span> <span class="n">paddr</span> <span class="mh">0x00000000</span> <span class="n">align</span> <span class="mi">2</span><span class="o">**</span><span class="mi">4</span>
</span></span><span class="line"><span class="cl">         <span class="n">filesz</span> <span class="mh">0x00000000</span> <span class="n">memsz</span> <span class="mh">0x00000000</span> <span class="n">flags</span> <span class="n">rwx</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Sections</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="n">Idx</span> <span class="n">Name</span>          <span class="n">Size</span>      <span class="n">VMA</span>       <span class="n">LMA</span>       <span class="ne">File</span> <span class="n">off</span>  <span class="n">Algn</span>
</span></span><span class="line"><span class="cl">  <span class="mi">0</span> <span class="o">.</span><span class="n">text</span>         <span class="mi">0000017</span><span class="n">c</span>  <span class="mi">00007</span><span class="n">c00</span>  <span class="mi">00007</span><span class="n">c00</span>  <span class="mi">00000074</span>  <span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">                  <span class="n">CONTENTS</span><span class="p">,</span> <span class="n">ALLOC</span><span class="p">,</span> <span class="n">LOAD</span><span class="p">,</span> <span class="n">CODE</span>
</span></span><span class="line"><span class="cl">  <span class="mi">1</span> <span class="o">.</span><span class="n">eh_frame</span>     <span class="mi">000000</span><span class="n">b0</span>  <span class="mi">00007</span><span class="n">d7c</span>  <span class="mi">00007</span><span class="n">d7c</span>  <span class="mi">000001</span><span class="n">f0</span>  <span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">                  <span class="n">CONTENTS</span><span class="p">,</span> <span class="n">ALLOC</span><span class="p">,</span> <span class="n">LOAD</span><span class="p">,</span> <span class="n">READONLY</span><span class="p">,</span> <span class="n">DATA</span>
</span></span><span class="line"><span class="cl">  <span class="mi">2</span> <span class="o">.</span><span class="n">stab</span>         <span class="mi">000007</span><span class="n">b0</span>  <span class="mi">00000000</span>  <span class="mi">00000000</span>  <span class="mi">000002</span><span class="n">a0</span>  <span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">                  <span class="n">CONTENTS</span><span class="p">,</span> <span class="n">READONLY</span><span class="p">,</span> <span class="n">DEBUGGING</span>
</span></span><span class="line"><span class="cl">  <span class="mi">3</span> <span class="o">.</span><span class="n">stabstr</span>      <span class="mi">00000846</span>  <span class="mi">00000000</span>  <span class="mi">00000000</span>  <span class="mi">00000</span><span class="n">a50</span>  <span class="mi">2</span><span class="o">**</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">                  <span class="n">CONTENTS</span><span class="p">,</span> <span class="n">READONLY</span><span class="p">,</span> <span class="n">DEBUGGING</span>
</span></span><span class="line"><span class="cl">  <span class="mi">4</span> <span class="o">.</span><span class="n">comment</span>      <span class="mi">0000002</span><span class="n">b</span>  <span class="mi">00000000</span>  <span class="mi">00000000</span>  <span class="mi">00001296</span>  <span class="mi">2</span><span class="o">**</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">                  <span class="n">CONTENTS</span><span class="p">,</span> <span class="n">READONLY</span>
</span></span><span class="line"><span class="cl"><span class="n">SYMBOL</span> <span class="n">TABLE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">c00</span> <span class="n">l</span>    <span class="n">d</span>  <span class="o">.</span><span class="n">text</span>    <span class="mi">00000000</span> <span class="o">.</span><span class="n">text</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">d7c</span> <span class="n">l</span>    <span class="n">d</span>  <span class="o">.</span><span class="n">eh_frame</span>    <span class="mi">00000000</span> <span class="o">.</span><span class="n">eh_frame</span>
</span></span><span class="line"><span class="cl"><span class="mi">00000000</span> <span class="n">l</span>    <span class="n">d</span>  <span class="o">.</span><span class="n">stab</span>    <span class="mi">00000000</span> <span class="o">.</span><span class="n">stab</span>
</span></span><span class="line"><span class="cl"><span class="mi">00000000</span> <span class="n">l</span>    <span class="n">d</span>  <span class="o">.</span><span class="n">stabstr</span>    <span class="mi">00000000</span> <span class="o">.</span><span class="n">stabstr</span>
</span></span><span class="line"><span class="cl"><span class="mi">00000000</span> <span class="n">l</span>    <span class="n">d</span>  <span class="o">.</span><span class="n">comment</span>    <span class="mi">00000000</span> <span class="o">.</span><span class="n">comment</span>
</span></span><span class="line"><span class="cl"><span class="mi">00000000</span> <span class="n">l</span>    <span class="n">df</span> <span class="o">*</span><span class="n">ABS</span><span class="o">*</span>    <span class="mi">00000000</span> <span class="n">obj</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">boot</span><span class="o">.</span><span class="n">o</span>
</span></span><span class="line"><span class="cl"><span class="mi">00000008</span> <span class="n">l</span>       <span class="o">*</span><span class="n">ABS</span><span class="o">*</span>    <span class="mi">00000000</span> <span class="n">PROT_MODE_CSEG</span>
</span></span><span class="line"><span class="cl"><span class="mi">00000010</span> <span class="n">l</span>       <span class="o">*</span><span class="n">ABS</span><span class="o">*</span>    <span class="mi">00000000</span> <span class="n">PROT_MODE_DSEG</span>
</span></span><span class="line"><span class="cl"><span class="mi">00000001</span> <span class="n">l</span>       <span class="o">*</span><span class="n">ABS</span><span class="o">*</span>    <span class="mi">00000000</span> <span class="n">CR0_PE_ON</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">c0a</span> <span class="n">l</span>       <span class="o">.</span><span class="n">text</span>    <span class="mi">00000000</span> <span class="n">seta20</span><span class="o">.</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">c14</span> <span class="n">l</span>       <span class="o">.</span><span class="n">text</span>    <span class="mi">00000000</span> <span class="n">seta20</span><span class="o">.</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">c64</span> <span class="n">l</span>       <span class="o">.</span><span class="n">text</span>    <span class="mi">00000000</span> <span class="n">gdtdesc</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">c32</span> <span class="n">l</span>       <span class="o">.</span><span class="n">text</span>    <span class="mi">00000000</span> <span class="n">protcseg</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">c4a</span> <span class="n">l</span>       <span class="o">.</span><span class="n">text</span>    <span class="mi">00000000</span> <span class="n">spin</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">c4c</span> <span class="n">l</span>       <span class="o">.</span><span class="n">text</span>    <span class="mi">00000000</span> <span class="n">gdt</span>
</span></span><span class="line"><span class="cl"><span class="mi">00000000</span> <span class="n">l</span>    <span class="n">df</span> <span class="o">*</span><span class="n">ABS</span><span class="o">*</span>    <span class="mi">00000000</span> <span class="n">main</span><span class="o">.</span><span class="n">c</span>
</span></span><span class="line"><span class="cl"><span class="mi">00000000</span> <span class="n">l</span>    <span class="n">df</span> <span class="o">*</span><span class="n">ABS</span><span class="o">*</span>    <span class="mi">00000000</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">c6a</span> <span class="n">g</span>     <span class="n">F</span> <span class="o">.</span><span class="n">text</span>    <span class="mi">00000012</span> <span class="n">waitdisk</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">d0a</span> <span class="n">g</span>     <span class="n">F</span> <span class="o">.</span><span class="n">text</span>    <span class="mi">00000072</span> <span class="n">bootmain</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">cd1</span> <span class="n">g</span>     <span class="n">F</span> <span class="o">.</span><span class="n">text</span>    <span class="mi">00000039</span> <span class="n">readseg</span>
</span></span><span class="line"><span class="cl"><span class="mf">00007e2</span><span class="n">c</span> <span class="n">g</span>       <span class="o">.</span><span class="n">eh_frame</span>    <span class="mi">00000000</span> <span class="n">__bss_start</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">c7c</span> <span class="n">g</span>     <span class="n">F</span> <span class="o">.</span><span class="n">text</span>    <span class="mi">00000055</span> <span class="n">readsect</span>
</span></span><span class="line"><span class="cl"><span class="mf">00007e2</span><span class="n">c</span> <span class="n">g</span>       <span class="o">.</span><span class="n">eh_frame</span>    <span class="mi">00000000</span> <span class="n">_edata</span>
</span></span><span class="line"><span class="cl"><span class="mf">00007e2</span><span class="n">c</span> <span class="n">g</span>       <span class="o">.</span><span class="n">eh_frame</span>    <span class="mi">00000000</span> <span class="n">_end</span>
</span></span><span class="line"><span class="cl"><span class="mi">00007</span><span class="n">c00</span> <span class="n">g</span>       <span class="o">.</span><span class="n">text</span>    <span class="mi">00000000</span> <span class="n">start</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为什么说只有text段是被使用到的呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">boot/Makefrag
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$(OBJDIR)/boot/boot: $(BOOT_OBJS)
</span></span><span class="line"><span class="cl">    @echo + ld boot/boot
</span></span><span class="line"><span class="cl">    $(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o $@.out $^ 
</span></span><span class="line"><span class="cl">    $(V)$(OBJDUMP) -S $@.out &gt;$@.asm
</span></span><span class="line"><span class="cl">    $(V)$(OBJCOPY) -S -O binary -j .text $@.out $@ # 380 bytes
</span></span><span class="line"><span class="cl">    $(V)perl boot/sign.pl $(OBJDIR)/boot/boot
</span></span></code></pre></td></tr></table>
</div>
</div><p>boot loader自己是没有利用ELF格式的。需要用boot sector固定的格式。不过加载的时候，却是采用了ELF格式来加载内核。
如果要详细看一下kernel各个段的加载情况，可以通过如下命令：
需要注意program header与sections的区别。program header是给加载程序方用的。
section是给写程序的人以及与编译器看的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ objdump -x obj/kern/kernel
</span></span><span class="line"><span class="cl">obj/kern/kernel:     file format elf32-i386
</span></span><span class="line"><span class="cl">obj/kern/kernel
</span></span><span class="line"><span class="cl">architecture: i386, flags 0x00000112:
</span></span><span class="line"><span class="cl">EXEC_P, HAS_SYMS, D_PAGED
</span></span><span class="line"><span class="cl">start address 0x0010000c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Program Header:
</span></span><span class="line"><span class="cl">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12
</span></span><span class="line"><span class="cl">         filesz 0x0000716c memsz 0x0000716c flags r-x
</span></span><span class="line"><span class="cl">    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12
</span></span><span class="line"><span class="cl">         filesz 0x0000a300 memsz 0x0000a944 flags rw-
</span></span><span class="line"><span class="cl">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
</span></span><span class="line"><span class="cl">         filesz 0x00000000 memsz 0x00000000 flags rwx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Sections:
</span></span><span class="line"><span class="cl">Idx Name          Size      VMA       LMA       File off  Algn
</span></span><span class="line"><span class="cl">  0 .text         00001917  f0100000  00100000  00001000  2**4
</span></span><span class="line"><span class="cl">                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span></span><span class="line"><span class="cl">  1 .rodata       00000714  f0101920  00101920  00002920  2**5
</span></span><span class="line"><span class="cl">                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span></span><span class="line"><span class="cl">  2 .stab         00003889  f0102034  00102034  00003034  2**2
</span></span><span class="line"><span class="cl">                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span></span><span class="line"><span class="cl">  3 .stabstr      000018af  f01058bd  001058bd  000068bd  2**0
</span></span><span class="line"><span class="cl">                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span></span><span class="line"><span class="cl">  4 .data         0000a300  f0108000  00108000  00009000  2**12
</span></span><span class="line"><span class="cl">                  CONTENTS, ALLOC, LOAD, DATA
</span></span><span class="line"><span class="cl">  5 .bss          00000644  f0112300  00112300  00013300  2**5
</span></span><span class="line"><span class="cl">                  ALLOC
</span></span><span class="line"><span class="cl">  6 .comment      0000002b  00000000  00000000  00013300  2**0
</span></span><span class="line"><span class="cl">                  CONTENTS, READONLY
</span></span><span class="line"><span class="cl">SYMBOL TABLE:
</span></span><span class="line"><span class="cl">f0100000 l    d  .text    00000000 .text
</span></span><span class="line"><span class="cl">f0101920 l    d  .rodata    00000000 .rodata
</span></span><span class="line"><span class="cl">f0102034 l    d  .stab    00000000 .stab
</span></span><span class="line"><span class="cl">f01058bd l    d  .stabstr    00000000 .stabstr
</span></span><span class="line"><span class="cl">f0108000 l    d  .data    00000000 .data
</span></span><span class="line"><span class="cl">f0112300 l    d  .bss    00000000 .bss
</span></span><span class="line"><span class="cl">00000000 l    d  .comment    00000000 .comment
</span></span><span class="line"><span class="cl">00000000 l    df *ABS*    00000000 obj/kern/entry.o
</span></span><span class="line"><span class="cl">f010002f l       .text    00000000 relocated
</span></span><span class="line"><span class="cl">f010003e l       .text    00000000 spin
</span></span><span class="line"><span class="cl">00000000 l    df *ABS*    00000000 entrypgdir.c
</span></span><span class="line"><span class="cl">00000000 l    df *ABS*    00000000 init.c
</span></span><span class="line"><span class="cl">00000000 l    df *ABS*    00000000 console.c
</span></span><span class="line"><span class="cl">f01001a0 l     F .text    0000001c serial_proc_data
</span></span><span class="line"><span class="cl">f01001bc l     F .text    00000044 cons_intr
</span></span><span class="line"><span class="cl">f0112320 l     O .bss    00000208 cons
</span></span><span class="line"><span class="cl">f0100200 l     F .text    00000117 kbd_proc_data
</span></span><span class="line"><span class="cl">f0112300 l     O .bss    00000004 shift.1330
</span></span><span class="line"><span class="cl">f0101b00 l     O .rodata    00000100 shiftcode
</span></span><span class="line"><span class="cl">f0101a00 l     O .rodata    00000100 togglecode
</span></span><span class="line"><span class="cl">f01019e0 l     O .rodata    00000010 charcode
</span></span><span class="line"><span class="cl">f0100317 l     F .text    000001e0 cons_putc
</span></span><span class="line"><span class="cl">f0112528 l     O .bss    00000002 crt_pos
</span></span><span class="line"><span class="cl">f011252c l     O .bss    00000004 crt_buf
</span></span><span class="line"><span class="cl">f0112530 l     O .bss    00000004 addr_6845
</span></span><span class="line"><span class="cl">f0112534 l     O .bss    00000001 serial_exists
</span></span><span class="line"><span class="cl">f0112200 l     O .data    00000100 normalmap
</span></span><span class="line"><span class="cl">f0112100 l     O .data    00000100 shiftmap
</span></span><span class="line"><span class="cl">f0112000 l     O .data    00000100 ctlmap
</span></span><span class="line"><span class="cl">00000000 l    df *ABS*    00000000 monitor.c
</span></span><span class="line"><span class="cl">f0101de4 l     O .rodata    00000018 commands
</span></span><span class="line"><span class="cl">00000000 l    df *ABS*    00000000 printf.c
</span></span><span class="line"><span class="cl">f01008eb l     F .text    00000013 putch
</span></span><span class="line"><span class="cl">00000000 l    df *ABS*    00000000 kdebug.c
</span></span><span class="line"><span class="cl">f010094b l     F .text    000000dd stab_binsearch
</span></span><span class="line"><span class="cl">00000000 l    df *ABS*    00000000 printfmt.c
</span></span><span class="line"><span class="cl">f0100c10 l     F .text    000000ef printnum
</span></span><span class="line"><span class="cl">f0100cff l     F .text    0000001d sprintputch
</span></span><span class="line"><span class="cl">f0102008 l     O .rodata    0000001c error_string
</span></span><span class="line"><span class="cl">00000000 l    df *ABS*    00000000 readline.c
</span></span><span class="line"><span class="cl">f0112540 l     O .bss    00000400 buf
</span></span><span class="line"><span class="cl">00000000 l    df *ABS*    00000000 string.c
</span></span><span class="line"><span class="cl">00000000 l    df *ABS*    00000000
</span></span><span class="line"><span class="cl">f010000c g       .text    00000000 entry
</span></span><span class="line"><span class="cl">f0101337 g     F .text    00000020 strcpy
</span></span><span class="line"><span class="cl">f0100513 g     F .text    00000012 kbd_intr
</span></span><span class="line"><span class="cl">f010079f g     F .text    0000000a mon_backtrace
</span></span><span class="line"><span class="cl">f01000f8 g     F .text    0000005f _panic
</span></span><span class="line"><span class="cl">f010009d g     F .text    0000005b i386_init
</span></span><span class="line"><span class="cl">f01014d4 g     F .text    00000068 memmove
</span></span><span class="line"><span class="cl">f0101208 g     F .text    00000028 snprintf
</span></span><span class="line"><span class="cl">f0100d44 g     F .text    0000046c vprintfmt
</span></span><span class="line"><span class="cl">f0100525 g     F .text    0000004a cons_getc
</span></span><span class="line"><span class="cl">f0100931 g     F .text    0000001a cprintf
</span></span><span class="line"><span class="cl">f010153c g     F .text    00000021 memcpy
</span></span><span class="line"><span class="cl">f0101230 g     F .text    000000ca readline
</span></span><span class="line"><span class="cl">f0111000 g     O .data    00001000 entry_pgtable
</span></span><span class="line"><span class="cl">f0100040 g     F .text    0000005d test_backtrace
</span></span><span class="line"><span class="cl">f01011b0 g     F .text    00000058 vsnprintf
</span></span><span class="line"><span class="cl">f0112300 g       .data    00000000 edata
</span></span><span class="line"><span class="cl">f010056f g     F .text    000000f2 cons_init
</span></span><span class="line"><span class="cl">f01058bc g       .stab    00000000 __STAB_END__
</span></span><span class="line"><span class="cl">f01058bd g       .stabstr    00000000 __STABSTR_BEGIN__
</span></span><span class="line"><span class="cl">f01017c0 g     F .text    00000157 .hidden __umoddi3
</span></span><span class="line"><span class="cl">f01004f7 g     F .text    0000001c serial_intr
</span></span><span class="line"><span class="cl">f0101690 g     F .text    00000124 .hidden __udivdi3
</span></span><span class="line"><span class="cl">f0100682 g     F .text    0000000a iscons
</span></span><span class="line"><span class="cl">f01015b3 g     F .text    000000d3 strtol
</span></span><span class="line"><span class="cl">f0101318 g     F .text    0000001f strnlen
</span></span><span class="line"><span class="cl">f0101357 g     F .text    0000002b strcat
</span></span><span class="line"><span class="cl">f0112940 g     O .bss    00000004 panicstr
</span></span><span class="line"><span class="cl">f0112944 g       .bss    00000000 end
</span></span><span class="line"><span class="cl">f0100157 g     F .text    00000045 _warn
</span></span><span class="line"><span class="cl">f010146b g     F .text    0000001c strfind
</span></span><span class="line"><span class="cl">f0101917 g       .text    00000000 etext
</span></span><span class="line"><span class="cl">0010000c g       .text    00000000 _start
</span></span><span class="line"><span class="cl">f01013af g     F .text    0000003d strlcpy
</span></span><span class="line"><span class="cl">f0101412 g     F .text    00000038 strncmp
</span></span><span class="line"><span class="cl">f0101382 g     F .text    0000002d strncpy
</span></span><span class="line"><span class="cl">f010155d g     F .text    00000039 memcmp
</span></span><span class="line"><span class="cl">f0100661 g     F .text    00000010 cputchar
</span></span><span class="line"><span class="cl">f0101487 g     F .text    0000004d memset
</span></span><span class="line"><span class="cl">f0100671 g     F .text    00000011 getchar
</span></span><span class="line"><span class="cl">f0100d1c g     F .text    00000028 printfmt
</span></span><span class="line"><span class="cl">f010716b g       .stabstr    00000000 __STABSTR_END__
</span></span><span class="line"><span class="cl">f01013ec g     F .text    00000026 strcmp
</span></span><span class="line"><span class="cl">f0100a28 g     F .text    000001d9 debuginfo_eip
</span></span><span class="line"><span class="cl">f01008fe g     F .text    00000033 vcprintf
</span></span><span class="line"><span class="cl">f0110000 g       .data    00000000 bootstacktop
</span></span><span class="line"><span class="cl">f0110000 g     O .data    00001000 entry_pgdir
</span></span><span class="line"><span class="cl">f0108000 g       .data    00000000 bootstack
</span></span><span class="line"><span class="cl">f0102034 g       .stab    00000000 __STAB_BEGIN__
</span></span><span class="line"><span class="cl">f0101300 g     F .text    00000018 strlen
</span></span><span class="line"><span class="cl">f010144a g     F .text    00000021 strchr
</span></span><span class="line"><span class="cl">f01006d5 g     F .text    000000ca mon_kerninfo
</span></span><span class="line"><span class="cl">f01007a9 g     F .text    00000142 monitor
</span></span><span class="line"><span class="cl">f0101596 g     F .text    0000001d memfind
</span></span><span class="line"><span class="cl">f0100690 g     F .text    00000045 mon_help
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此，这里可以看出来。program headers 就是写在ELF头里面给加载程序用的。但是这里主要关注：</p>
<ul>
<li>vaddr 加载后程序内部引用的各种虚拟地址基地址</li>
<li>paddr 加载到的物理基地址</li>
<li>memsz 这个程序段的大小</li>
<li>filesz 这个程序段所在位置起始位置。注意，这里是相对于文件头而言。 ！！</li>
</ul>
<p>这么四个变量。使用-x 输出太长了。虽然里面有些信息lab2会用到。不过对于lab1而言。只需要如下命令就可以理解了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ objdump -p obj/kern/kernel
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">obj/kern/kernel:     file format elf32-i386
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Program Header:
</span></span><span class="line"><span class="cl">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12
</span></span><span class="line"><span class="cl">         filesz 0x0000716c memsz 0x0000716c flags r-x
</span></span><span class="line"><span class="cl">    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12
</span></span><span class="line"><span class="cl">         filesz 0x0000a300 memsz 0x0000a944 flags rw-
</span></span><span class="line"><span class="cl">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
</span></span><span class="line"><span class="cl">         filesz 0x00000000 memsz 0x00000000 flags rwx
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="exercise5">exercise5</h3>
<p>将bootloader的起始地址修改为-Ttext 0x7c01，在make qemu，随后在该地址打上断点。发生了陷入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">Breakpoint</span> <span class="mi">1</span> <span class="n">at</span> <span class="mh">0x7c01</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">c</span>
</span></span><span class="line"><span class="cl"><span class="n">Continuing</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Program</span> <span class="n">received</span> <span class="k">signal</span> <span class="n">SIGTRAP</span><span class="p">,</span> <span class="n">Trace</span><span class="o">/</span><span class="k">breakpoint</span> <span class="n">trap</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span>   <span class="mi">0</span><span class="p">:</span><span class="mi">7</span><span class="n">c30</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mh">0x7c30</span><span class="p">:</span>  <span class="n">ljmp</span>   <span class="o">$</span><span class="mh">0x8</span><span class="p">,</span><span class="o">$</span><span class="mh">0x7c36</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">EAX=00000011 EBX=00000000 ECX=00000000 EDX=00000080
</span></span><span class="line"><span class="cl">ESI=00000000 EDI=00000000 EBP=00000000 ESP=00006f20
</span></span><span class="line"><span class="cl">EIP=00007c30 EFL=00000006 [-----P-] CPL=0 II=0 A20=1 SMM=0 HLT=0
</span></span><span class="line"><span class="cl">ES =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]
</span></span><span class="line"><span class="cl">CS =0000 00000000 0000ffff 00009b00 DPL=0 CS16 [-RA]
</span></span><span class="line"><span class="cl">SS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]
</span></span><span class="line"><span class="cl">DS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]
</span></span><span class="line"><span class="cl">FS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]
</span></span><span class="line"><span class="cl">GS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]
</span></span><span class="line"><span class="cl">LDT=0000 00000000 0000ffff 00008200 DPL=0 LDT
</span></span><span class="line"><span class="cl">TR =0000 00000000 0000ffff 00008b00 DPL=0 TSS32-busy
</span></span><span class="line"><span class="cl">GDT=     0000007c 00005000
</span></span><span class="line"><span class="cl">IDT=     00000000 000003ff
</span></span><span class="line"><span class="cl">CR0=00000011 CR2=00000000 CR3=00000000 CR4=00000000
</span></span><span class="line"><span class="cl">DR0=00000000 DR1=00000000 DR2=00000000 DR3=00000000 
</span></span><span class="line"><span class="cl">DR6=ffff0ff0 DR7=00000400
</span></span><span class="line"><span class="cl">EFER=0000000000000000
</span></span><span class="line"><span class="cl">Triple fault.  Halting for inspection via QEMU monitor
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="exercies6">exercies6</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Q:在 BIOS 进入引导加载程序时检查 0x00100000 处的 8 个内存字，然后在引导加载程序进入内核时再次检查。他们为什么不同？第二个断点是什么？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">A:
</span></span><span class="line"><span class="cl">(gdb) b *0x7c00
</span></span><span class="line"><span class="cl">Breakpoint 1 at 0x7c00
</span></span><span class="line"><span class="cl">(gdb) b *0x7d81
</span></span><span class="line"><span class="cl">Breakpoint 2 at 0x7d81
</span></span><span class="line"><span class="cl">(gdb) c
</span></span><span class="line"><span class="cl">Continuing.
</span></span><span class="line"><span class="cl">[   0:7c00] =&gt; 0x7c00:  cli    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Breakpoint 1, 0x00007c00 in ?? ()
</span></span><span class="line"><span class="cl">(gdb) x/8x 0x100000
</span></span><span class="line"><span class="cl">0x100000:       0x00000000      0x00000000      0x00000000      0x00000000
</span></span><span class="line"><span class="cl">0x100010:       0x00000000      0x00000000      0x00000000      0x00000000
</span></span><span class="line"><span class="cl">(gdb) c
</span></span><span class="line"><span class="cl">Continuing.
</span></span><span class="line"><span class="cl">The target architecture is assumed to be i386
</span></span><span class="line"><span class="cl">=&gt; 0x7d81:      call   *0x10018
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Breakpoint 2, 0x00007d81 in ?? ()
</span></span><span class="line"><span class="cl">(gdb) x/8x 0x100000
</span></span><span class="line"><span class="cl">0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766
</span></span><span class="line"><span class="cl">0x100010:       0x34000004      0x2000b812      0x220f0011      0xc0200fd8
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">不运行QEMU也可以知道原因，在BIOS进入引导程序的时候，还没有讲内核程序加载到内存中，因此0X10000之后的8个字肯定为0。而在BootLoader进入内核时，此时已经在内核程序加载在0X10000中。
</span></span></code></pre></td></tr></table>
</div>
</div><p>在entry.S中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">.</span><span class="n">text</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># The Multiboot header</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">align</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">long</span> <span class="n">MULTIBOOT_HEADER_MAGIC</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">long</span> <span class="n">MULTIBOOT_HEADER_FLAGS</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">long</span> <span class="n">CHECKSUM</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># &#39;_start&#39; specifies the ELF entry point.  Since we haven&#39;t set up</span>
</span></span><span class="line"><span class="cl"><span class="c1"># virtual memory when the bootloader enters this code, we need the</span>
</span></span><span class="line"><span class="cl"><span class="c1"># bootloader to jump to the *physical* address of the entry point.</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">globl</span>		<span class="n">_start</span>
</span></span><span class="line"><span class="cl"><span class="n">_start</span> <span class="o">=</span> <span class="n">RELOC</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">globl</span> <span class="n">entry</span>
</span></span><span class="line"><span class="cl"><span class="n">entry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">movw</span>	<span class="o">$</span><span class="mh">0x1234</span><span class="p">,</span><span class="mh">0x472</span>			<span class="c1"># warm boot</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>前三个字正好对应0X10000中的前三个字</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="part3-the-kernel">Part3 The Kernel</h2>
<h3 id="exercise7">exercise7</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Ｑ：用Qemu和GDB跳到JOS的内核里面。并且暂停在movl %eax, %cr0这条指令这里。验证内存两个地址：0x00100000 and at 0xf0100000。接下来用s指令一条一条地执行。然后再验证一下这个两个内存地址的内容。确保你理解整个发生的过程。
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先需要明白：程序地址与寻址地址</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1. 程序代码地址
</span></span><span class="line"><span class="cl">2. 支持的寻址地址
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果支持的寻址地址不支持汇编里面的地址（比如页表没有建立起来）。比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mov %eax, *$0xf0100000
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个时候必须要知道0xf0100000真正的物理地址是什么。程序代码里直接成相应的物理地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#define    RELOC(x) ((x) - KERNBASE)
</span></span></code></pre></td></tr></table>
</div>
</div><p>示例1： kernel的入口地址</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="c1"># &#39;_start&#39; specifies the ELF entry point.  Since we haven&#39;t set up</span>
</span></span><span class="line"><span class="cl"><span class="c1"># virtual memory when the bootloader enters this code, we need the</span>
</span></span><span class="line"><span class="cl"><span class="c1"># bootloader to jump to the *physical* address of the entry point.</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">globl</span>        <span class="n">_start</span>
</span></span><span class="line"><span class="cl"><span class="n">_start</span> <span class="o">=</span> <span class="n">RELOC</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">globl</span> <span class="n">entry</span>
</span></span><span class="line"><span class="cl"><span class="n">entry</span><span class="p">:</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>kernel在编译的时候是并不知道会被加载到哪里的。通过链接的时候kern/kernel.ld链接脚本可以指令被加载到的物理地址。但是程序的入口地址仍然需要告知ELF。
ELF执行的格式是<code>_start</code>是入口。如果不加任何处理，那么<code>_start</code>就是一个虚拟地址。这个值会反应在ELF header-&gt;e_entry值上面。(看boot/main.c)里面的跳转到内核的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// call the entry point from the ELF header
</span></span><span class="line"><span class="cl"> // note: does not return!
</span></span><span class="line"><span class="cl"> ((void (*)(void)) (ELFHDR-&gt;e_entry))();
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里面<code>e_entry</code>就指向<code>_start</code>值。由于从<code>boot loader</code>跳转到的内核的时候，还在物理地址与虚拟地址完全重合的情况。并且也没有开启分页。所以这个时候必须在kern/entry.S里面</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.globl        _start
</span></span><span class="line"><span class="cl">_start = RELOC(entry)
</span></span></code></pre></td></tr></table>
</div>
</div><p>把<code>_start</code>地址改造成物理地址。这会儿，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">root@debug:~/6.828/lab# objdump -f obj/kern/kernel
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">obj/kern/kernel:     file format elf32-i386
</span></span><span class="line"><span class="cl">architecture: i386, flags 0x00000112:
</span></span><span class="line"><span class="cl">EXEC_P, HAS_SYMS, D_PAGED
</span></span><span class="line"><span class="cl">start address 0x0010000c
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个时候<code>start address</code>就是一个物理地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">f010000c &lt;entry&gt;:
</span></span><span class="line"><span class="cl">f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
</span></span></code></pre></td></tr></table>
</div>
</div><p>这也就是为什么进入kernel的第一条指令在地址0x10000c（0xf01000c是虚拟地址）</p>
<p><strong>原问题的正解</strong></p>
<p>首先对<code>entry.S</code>代码加以注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">	<span class="cp"># Load the physical address of entry_pgdir into cr3.  entry_pgdir
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="cp"># is defined in entrypgdir.c.
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="n">movl</span>	<span class="err">$</span><span class="p">(</span><span class="nf">RELOC</span><span class="p">(</span><span class="n">entry_pgdir</span><span class="p">)),</span> <span class="o">%</span><span class="n">eax</span>
</span></span><span class="line"><span class="cl"><span class="nl">f0100015</span><span class="p">:</span>	<span class="n">b8</span> <span class="mo">00</span> <span class="mi">20</span> <span class="mi">11</span> <span class="mo">00</span>       	<span class="n">mov</span>    <span class="err">$</span><span class="mh">0x112000</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
</span></span><span class="line"><span class="cl">	<span class="n">movl</span>	<span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">cr3</span>
</span></span><span class="line"><span class="cl">	<span class="err">将</span><span class="mh">0x112000</span><span class="err">也就是页目录的物理地址放入</span><span class="n">cr3寄存器中</span>
</span></span><span class="line"><span class="cl"><span class="nl">f010001a</span><span class="p">:</span>	<span class="mf">0f</span> <span class="mi">22</span> <span class="n">d8</span>             	<span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">cr3</span>
</span></span><span class="line"><span class="cl">	<span class="cp"># Turn on paging.
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="n">movl</span>	<span class="o">%</span><span class="n">cr0</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span></span><span class="line"><span class="cl"><span class="nl">f010001d</span><span class="p">:</span>	<span class="mf">0f</span> <span class="mi">20</span> <span class="n">c0</span>             	<span class="n">mov</span>    <span class="o">%</span><span class="n">cr0</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
</span></span><span class="line"><span class="cl">	<span class="n">orl</span>	<span class="err">$</span><span class="p">(</span><span class="n">CR0_PE</span><span class="o">|</span><span class="n">CR0_PG</span><span class="o">|</span><span class="n">CR0_WP</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
</span></span><span class="line"><span class="cl"><span class="nl">f0100020</span><span class="p">:</span>	<span class="mi">0</span><span class="n">d</span> <span class="mo">01</span> <span class="mo">00</span> <span class="mo">01</span> <span class="mi">80</span>       	<span class="n">or</span>     <span class="err">$</span><span class="mh">0x80010001</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
</span></span><span class="line"><span class="cl">	<span class="n">movl</span>	<span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">cr0</span>
</span></span><span class="line"><span class="cl"><span class="nl">f0100025</span><span class="p">:</span>	<span class="mf">0f</span> <span class="mi">22</span> <span class="n">c0</span>             	<span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">cr0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以原问题中在开启分页前去看<code>0xf0100000</code>地址时。肯定为0。因为在当前地址空间里面，这部分虚拟地址是没有内容的。页表也还没有。只能是假装去访问物理地址。
分页后去查看地址时。<code>0xf0100000</code>与<code>0x00100000</code>内容就完全一样了。这是因为把<code>[0, 4MB)</code>映射到了<code>[0xf0000000, 0xf0000000 + 4MB)</code>的地方了。
开启分页后的跳转</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">       <span class="cp"># Now paging is enabled, but we&#39;re still running at a low EIP
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp"># (why is this okay?).  Jump up above KERNBASE before entering
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp"># C code.
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="n">mov</span>     <span class="err">$</span><span class="n">relocated</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span></span><span class="line"><span class="cl">        <span class="n">jmp</span>     <span class="o">*%</span><span class="n">eax</span>
</span></span><span class="line"><span class="cl"><span class="nl">relocated</span><span class="p">:</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当开启分页之后，立马会进行相应的跳转。这里主要是因为后面会开始执行C语言的函数了。必须设置好相应的CS:IP, esp, ebp, ss等寄存器。如果还是在物理地址空间运行。但是C语言是以为自己在虚拟地址空间运行的。</p>
<ul>
<li>
<ol>
<li>CPU跑在物理地址空间上，而不是虚拟地址空间上。（尽管CS:IP会被翻译到真正的地址。）</li>
</ol>
</li>
<li>
<ol>
<li>C语言认为是自己是跑在虚拟地址空间。</li>
</ol>
</li>
</ul>
<p>通过jmp，可以使得两者正常化。CPU在取指，寻址的时候，就会在有页映射的地址空间里面了。环境设置好，就可以开始跳转到C语言里面了。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111296.png"
        data-srcset="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111296.png, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111296.png 1.5x, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111296.png 2x"
        data-sizes="auto"
        alt="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111296.png"
        title="image-20230425151557478" /></p>
<p>可以发现，两者内容完全一致，虚拟地址<code>0xf0100000</code>已经被映射到<code>0x00100000</code>处了,为什么会出现这种变化？
在修改cr0之前修改了cr3寄存器。将地址<code>0x112000</code>写入了页目录寄存器，页目录表应该就是存放在地址<code>0x112000</code>处。其他操作应该是由<code>entry_pgdir</code>的// Map VA&rsquo;s [KERNBASE, KERNBASE+4MB) to PA&rsquo;s [0, 4MB)，完成了映射。使得再读取<code>0xf0100000</code>地址时，自动映射到了<code>0~4M</code>的某个位置（暂时不清楚）。</p>
<blockquote>
<p>CR3是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的低12位总为0，不起作用，即使写上内容，也不会被理会。</p>
</blockquote>
<p><strong>2. What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the <code>movl %eax, %cr0</code> in <code>kern/entry.S</code>, trace into it, and see if you were right.</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Q:*建立新映射后，*如果映射不存在，将无法正常工作的 第一条指令是什么？注释掉`kern/entry.S``movl %eax, %cr0`中的 内容，跟踪它，看看你是否正确。
</span></span></code></pre></td></tr></table>
</div>
</div><p>主要意思是说，如果把movl %eax, %cr0删除掉会发生什么样的情况。
删除掉之后，只要后面有涉及到寻址的地方，就会立马出错。假设把这一行注释掉。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    # movl    %eax, %cr0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    # Now paging is enabled, but we&#39;re still running at a low EIP
</span></span><span class="line"><span class="cl">    # (why is this okay?).  Jump up above KERNBASE before entering
</span></span><span class="line"><span class="cl">    # C code.
</span></span><span class="line"><span class="cl">    mov    $relocated, %eax
</span></span><span class="line"><span class="cl">    jmp    *%eax
</span></span><span class="line"><span class="cl">relocated:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    # Clear the frame pointer register (EBP)
</span></span><span class="line"><span class="cl">    # so that once we get into debugging C code,
</span></span><span class="line"><span class="cl">    # stack backtraces will be terminated properly.
</span></span><span class="line"><span class="cl">    movl    $0x0,%ebp            # nuke frame pointer
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    # Set the stack pointer
</span></span><span class="line"><span class="cl">    movl    $(bootstacktop),%esp
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么在<code>movl $(bootstacktop), %esp</code>这里就立马出错了。</p>
<p>因为把<code>$bootstacktop</code>当成物理地址了。但是实际上，哪有那么大的物理地址空间。所以肯定会报错了。(万一真给了qemu那么大的物理地址空间，那边物理地址也没有内容，跳到C语言之后就会出错。)</p>
<h3 id="exercise8">exercise8</h3>
<p>仿照case ‘u’，其中putch是将字符打印在屏幕上</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">case &#39;o&#39;:
</span></span><span class="line"><span class="cl">			// Replace this with your code.
</span></span><span class="line"><span class="cl">			putch(&#39;0&#39;, putdat);//print 0 in front of octal
</span></span><span class="line"><span class="cl">            num = getuint(&amp;ap, lflag);
</span></span><span class="line"><span class="cl">            base = 8;
</span></span><span class="line"><span class="cl">            goto number;
</span></span></code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111126.png"
        data-srcset="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111126.png, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111126.png 1.5x, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111126.png 2x"
        data-sizes="auto"
        alt="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111126.png"
        title="image-20230425160250233" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Q：解释printf.c和 console.c之间的接口。具体 console.c导出的是什么功能？printf.c如何使用这个函数 ？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">A：
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里分析过程如下：
printf.c里面的调用链如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cprintf -&gt; vcprintf -&gt; vprintfmt -&gt; putch -&gt; cputchar
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后cputchar的声明是在</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">./inc/stdio.h:11:void    cputchar(int c);
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数的定义是在console.c</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void cputchar(int c)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">        cons_putc(c);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// output a character to the console
</span></span><span class="line"><span class="cl">static void
</span></span><span class="line"><span class="cl">cons_putc(int c)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">        serial_putc(c);
</span></span><span class="line"><span class="cl">        lpt_putc(c);
</span></span><span class="line"><span class="cl">        cga_putc(c);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下主要就是看<code>cga_putc</code>。也就是显示到屏幕上的函数。首先看一下<code>cga_init</code>。这个函数的功能就是选定特定的屏幕。比如<code>vga, cga</code>等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">static void cga_init(void)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">        volatile uint16_t *cp;
</span></span><span class="line"><span class="cl">        uint16_t was;
</span></span><span class="line"><span class="cl">        unsigned pos;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        cp = (uint16_t*) (KERNBASE + CGA_BUF);
</span></span><span class="line"><span class="cl">        was = *cp;
</span></span><span class="line"><span class="cl">        *cp = (uint16_t) 0xA55A;
</span></span><span class="line"><span class="cl">        if (*cp != 0xA55A) {
</span></span><span class="line"><span class="cl">                cp = (uint16_t*) (KERNBASE + MONO_BUF);
</span></span><span class="line"><span class="cl">                addr_6845 = MONO_BASE;
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">                *cp = was;
</span></span><span class="line"><span class="cl">                addr_6845 = CGA_BASE;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        /* Extract cursor location */
</span></span><span class="line"><span class="cl">        outb(addr_6845, 14);
</span></span><span class="line"><span class="cl">        pos = inb(addr_6845 + 1) &lt;&lt; 8;
</span></span><span class="line"><span class="cl">        outb(addr_6845, 15);
</span></span><span class="line"><span class="cl">        pos |= inb(addr_6845 + 1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        crt_buf = (uint16_t*) cp;
</span></span><span class="line"><span class="cl">        crt_pos = pos;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>一般而言，显示操作的时候，启动的时候，都是使用提<code>CGA</code>。也就是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">./kern/console.h:14:#define CGA_BUF        0xB8000
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化的时候，需要设定光标的位置。设置完成之后。就可以利用<code>cga_putc</code>来CGA屏幕上显示字符了。这里可以看出来，除了各个字符的设定之外。还随时移动的光标。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">cga_putc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// if no attribute given, then use black on white
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xFF</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span> <span class="o">|=</span> <span class="mh">0x0700</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">switch</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="sc">&#39;\b&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">crt_pos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">crt_pos</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">crt_buf</span><span class="p">[</span><span class="n">crt_pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xff</span><span class="p">)</span> <span class="o">|</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="sc">&#39;\n&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">crt_pos</span> <span class="o">+=</span> <span class="n">CRT_COLS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* fallthru */</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="sc">&#39;\r&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">crt_pos</span> <span class="o">-=</span> <span class="p">(</span><span class="n">crt_pos</span> <span class="o">%</span> <span class="n">CRT_COLS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="sc">&#39;\t&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                <span class="nf">cons_putc</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">cons_putc</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">cons_putc</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">cons_putc</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">cons_putc</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">crt_buf</span><span class="p">[</span><span class="n">crt_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>         <span class="cm">/* write the character */</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// What is the purpose of this?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">crt_pos</span> <span class="o">&gt;=</span> <span class="n">CRT_SIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="nf">memmove</span><span class="p">(</span><span class="n">crt_buf</span><span class="p">,</span> <span class="n">crt_buf</span> <span class="o">+</span> <span class="n">CRT_COLS</span><span class="p">,</span> <span class="p">(</span><span class="n">CRT_SIZE</span> <span class="o">-</span> <span class="n">CRT_COLS</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CRT_SIZE</span> <span class="o">-</span> <span class="n">CRT_COLS</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CRT_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="n">crt_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0700</span> <span class="o">|</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">crt_pos</span> <span class="o">-=</span> <span class="n">CRT_COLS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* move that little blinky thing */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">outb</span><span class="p">(</span><span class="n">addr_6845</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">outb</span><span class="p">(</span><span class="n">addr_6845</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">crt_pos</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">outb</span><span class="p">(</span><span class="n">addr_6845</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">outb</span><span class="p">(</span><span class="n">addr_6845</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">crt_pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Q</span><span class="err">：从</span><span class="n">console</span><span class="p">.</span><span class="n">c解释以下内容</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="err">如果</span> <span class="p">(</span><span class="n">crt_pos</span> <span class="o">&gt;=</span> <span class="n">CRT_SIZE</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="nf">memmove</span><span class="p">(</span><span class="n">crt_buf</span><span class="p">,</span> <span class="n">crt_buf</span> <span class="o">+</span> <span class="n">CRT_COLS</span><span class="p">,</span> <span class="p">(</span><span class="n">CRT_SIZE</span> <span class="o">-</span> <span class="n">CRT_COLS</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CRT_SIZE</span> <span class="o">-</span> <span class="n">CRT_COLS</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CRT_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="n">crt_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0700</span> <span class="o">|</span> <span class="sc">&#39; &#39;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="mi">6</span> <span class="n">crt_pos</span> <span class="o">-=</span> <span class="n">CRT_COLS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="mi">7</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define CRT_ROWS    25 行
</span></span></span><span class="line"><span class="cl"><span class="cp">#define CRT_COLS    80 列
</span></span></span><span class="line"><span class="cl"><span class="cp">#define CRT_SIZE    (CRT_ROWS * CRT_COLS)  25*80
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 一页写满，滚动一行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">crt_pos</span> <span class="o">&gt;=</span> <span class="n">CRT_SIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 把从第1~n行的内容复制到0~(n-1)行，第n行未变化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 通过这一行代码完成了整个屏幕向上移动一行的操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  	<span class="c1">// 即将[1,24]*80移到[0,23]*80
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memmove</span><span class="p">(</span><span class="n">crt_buf</span><span class="p">,</span> <span class="n">crt_buf</span> <span class="o">+</span> <span class="n">CRT_COLS</span><span class="p">,</span> <span class="p">(</span><span class="n">CRT_SIZE</span> <span class="o">-</span> <span class="n">CRT_COLS</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 把最后一行清空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CRT_SIZE</span> <span class="o">-</span> <span class="n">CRT_COLS</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CRT_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">crt_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0700</span> <span class="o">|</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 清空了最后一行，同步crt_pos
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">crt_pos</span> <span class="o">-=</span> <span class="n">CRT_COLS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">CRT_SIZE</span> <span class="o">-</span> <span class="n">CRT_COLS</span>  <span class="mi">24</span><span class="o">*</span><span class="mi">80</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">memmove</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">str1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">str2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="err">参数</span>
</span></span><span class="line"><span class="cl"><span class="n">str1</span> <span class="o">--</span> <span class="err">指向用于存储复制内容的目标数组，类型强制转换为</span> <span class="kt">void</span><span class="o">*</span> <span class="err">指针。</span>
</span></span><span class="line"><span class="cl"><span class="n">str2</span> <span class="o">--</span> <span class="err">指向要复制的数据源，类型强制转换为</span> <span class="kt">void</span><span class="o">*</span> <span class="err">指针。</span>
</span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">--</span> <span class="err">要被复制的字节数。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Q：对于以下问题，您可能希望查阅第 2 讲的注释。这些注释涵盖了 GCC 在 x86 上的调用约定。
</span></span><span class="line"><span class="cl">逐步跟踪以下代码的执行情况：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">整数 x = 1, y = 3, z = 4; 
</span></span><span class="line"><span class="cl">cprintf(&#34;x %d, y %x, z %d\n&#34;, x, y, z);
</span></span><span class="line"><span class="cl">在调用 cprintf()时，fmt指向什么？ap指向什么？
</span></span><span class="line"><span class="cl">列出（按执行顺序）对 cons_putc、va_arg和 的每次调用vcprintf。对于cons_putc，也列出其参数。对于 va_arg，列出ap调用前后指向的内容。对于vcprintf列出其两个参数的值。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">A：
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">putch</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cnt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">cputchar</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">vcprintf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">ap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">vprintfmt</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">putch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">cprintf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">va_list</span> <span class="n">ap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cnt</span> <span class="o">=</span> <span class="nf">vcprintf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如压入了5个char。也是需要用到2个long。在32位机器上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 指针定义为char *可以指向任意一个内存地址。
</span></span><span class="line"><span class="cl">typedef char *va_list;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 类型大小，注意这里是与CPU位数对齐 ＝ sizeof(long)的作用。
</span></span><span class="line"><span class="cl">#define    __va_size(type) \
</span></span><span class="line"><span class="cl">    (((sizeof(type) + sizeof(long) - 1) / sizeof(long)) * sizeof(long))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 这里个宏并不是取得参数的起始地址。而是说参数将从什么地址开始放。
</span></span><span class="line"><span class="cl">#define    va_start(ap, last) \
</span></span><span class="line"><span class="cl">    ((ap) = (va_list)&amp;(last) + __va_size(last))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// va_arg就是用来取参数的起始地址的。然后返回type类型。
</span></span><span class="line"><span class="cl">// 从整个表达式的意义来说没有什么好用的。
</span></span><span class="line"><span class="cl">// 其实等价于(*(type*)ap)
</span></span><span class="line"><span class="cl">// 但是实际上使ap指针移动一个参数大小。
</span></span><span class="line"><span class="cl">#define    va_arg(ap, type) \
</span></span><span class="line"><span class="cl">    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 空指令，没有什么用
</span></span><span class="line"><span class="cl">#define    va_end(ap)    ((void)0)
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以这里回到原来的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int x = 1, y = 3, z = 4;
</span></span><span class="line"><span class="cl">cprintf(&#34;x %d, y %x, z %d\n&#34;, x, y, z);
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>fmt</code>就是指向那个<code>const char *</code>的字符串。当调用的时候，栈中的结构是如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">+-----------------+
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     Z           |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     Y           |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     X           |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     fmt         |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+ &lt;-----------+&amp;fmt
</span></span><span class="line"><span class="cl">va_start(fmt, ap) 作用如下
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define    va_start(ap, last) \
</span></span><span class="line"><span class="cl">    ((ap) = (va_list)&amp;(last) + __va_size(last))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">展开就是
</span></span><span class="line"><span class="cl">ap = (char *)(&amp;fmt) + align_long(fmt);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">+-----------------+
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     Z           |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     Y           |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     X           |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+ &lt;--------------+ap
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     fmt         |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来简单一点，看一下调用到<code>%c</code>输出的时候，代码是怎么走的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">void</span>
</span></span><span class="line"><span class="cl"><span class="n">vprintfmt</span><span class="p">(</span><span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">putch</span><span class="p">)(</span><span class="ne">int</span><span class="p">,</span> <span class="n">void</span><span class="o">*</span><span class="p">),</span> <span class="n">void</span> <span class="o">*</span><span class="n">putdat</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">ap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">如果只是一般的字符串，直接输出。</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">((</span><span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fmt</span><span class="o">++</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">putch</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">putdat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">如果发现是</span><span class="o">%</span><span class="n">c</span>
</span></span><span class="line"><span class="cl">    <span class="n">reswitch</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">先把</span><span class="o">%</span><span class="err">号跳掉，取出</span><span class="s1">&#39;c&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fmt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="o">..</span> 
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">putch</span><span class="p">(</span><span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="ne">int</span><span class="p">),</span> <span class="n">putdat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个时候通过<code>%c</code>就知道应该从栈中取出一个参数char类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">va_arg(ap, int) 展开后就是
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define    va_arg(ap, type) \
</span></span><span class="line"><span class="cl">    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// putat用来统计输出的字符的个数。在这里可以不用去管
</span></span><span class="line"><span class="cl">char temp = *(char*)ap;
</span></span><span class="line"><span class="cl">putch(temp, putdat); // 输出到console上。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ap += align_long(char);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">执行完成之后。
</span></span><span class="line"><span class="cl">+-----------------+
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     Z           |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     Y           |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+ &lt;------+ap
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     X           |   这个x会被%d提出来进行输出。
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|     fmt         |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">|                 |
</span></span><span class="line"><span class="cl">+-----------------+
</span></span></code></pre></td></tr></table>
</div>
</div><p>从这里也可以总结出来。ap的作用实际上就是利用fmt里面的<code>%</code>依次把后面的类型提出来。
然后去栈中找到参数。一个一个输出。</p>
<blockquote>
<p>从这个练习可以看出来，正是因为C函数调用实参的入栈顺序是从右到左的，才使得调用参数个数可变的函数成为可能(且不用显式地指出参数的个数)。但是必须有一个方式来告诉实际调用时传入的参数到底是几个，这个是在格式化字符串中指出的。如果这个格式化字符串指出的参数个数和实际传入的个数不一致，比如说传入的参数比格式化字符串指出的要少，就可能会使用到栈上错误的内存作为传入的参数，编译器必须检查出这样的错误。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Q：运行以下代码。
</span></span><span class="line"><span class="cl">    无符号整数 i = 0x00646c72；
</span></span><span class="line"><span class="cl">    cprintf(&#34;H%x Wo%s&#34;, 57616, &amp;i);
</span></span><span class="line"><span class="cl">输出是什么？解释如何按照上一个练习的逐步方式得出这个输出。 这是一个将字节映射到字符的 ASCII 表。
</span></span><span class="line"><span class="cl">输出取决于 x86 是小端字节序这一事实。如果 x86 是 big-endian 你会设置什么i来产生相同的输出？您需要更改 57616为不同的值吗？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这是对小端和大端的描述 以及 更异想天开的描述。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">A：
</span></span><span class="line"><span class="cl">57616 = 0xE110。
</span></span><span class="line"><span class="cl">i = 0x00646c72
</span></span><span class="line"><span class="cl">那么如果把i占用的4byte转换成为char[4]数组。结果就是：
</span></span><span class="line"><span class="cl">char str[4] = {0x72, 0x6c, 0x64, 0x00}; // = {&#39;r&#39;, &#39;l&#39;, &#39;d&#39;, 0}
</span></span><span class="line"><span class="cl">所以输出就是
</span></span><span class="line"><span class="cl">Hell0 World
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Q：在下面的代码中，将在 之后打印什么 &#39;y=&#39;？（注意：答案不是具体值。）为什么会出现这种情况？
</span></span><span class="line"><span class="cl">    cprintf(&#34;x=%dy=%d&#34;, 3);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">A：在a0-a7中存放参数，因此取决于寄存器a2保存的值
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Q：假设 GCC 更改了它的调用约定，以便它按声明顺序将参数压入堆栈，以便最后一个参数被压入最后。您将如何更改cprintf它的接口，以便仍然可以向它传递可变数量的参数？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">A：其实也还是可以拿到参数的。只不过需要把宏的加减法改一下就可以了。把这里的加法改成减法，减法改成加法。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 指针定义为char *可以指向任意一个内存地址。
</span></span><span class="line"><span class="cl">typedef char *va_list;
</span></span><span class="line"><span class="cl">// 类型大小，注意这里是与CPU位数对齐 ＝ sizeof(long)的作用。
</span></span><span class="line"><span class="cl">#define    __va_size(type) \
</span></span><span class="line"><span class="cl">    (((sizeof(type) + sizeof(long) - 1) / sizeof(long)) * sizeof(long))
</span></span><span class="line"><span class="cl">// 这里个宏并不是取得参数的起始地址。而是说参数将从什么地址开始放。
</span></span><span class="line"><span class="cl">#define    va_start(ap, last) \
</span></span><span class="line"><span class="cl">    ((ap) = (va_list)&amp;(last) + __va_size(last))
</span></span><span class="line"><span class="cl">// va_arg就是用来取参数的起始地址的。然后返回type类型。
</span></span><span class="line"><span class="cl">// 从整个表达式的意义来说没有什么好用的。
</span></span><span class="line"><span class="cl">// 其实等价于(*(type*)ap)
</span></span><span class="line"><span class="cl">// 但是实际上使ap指针移动一个参数大小。
</span></span><span class="line"><span class="cl">#define    va_arg(ap, type) \
</span></span><span class="line"><span class="cl">    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))
</span></span><span class="line"><span class="cl">// 空指令，没有什么用
</span></span><span class="line"><span class="cl">#define    va_end(ap)    ((void)0)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="the-stack">The Stack</h3>
<h3 id="exercise9">exercise9</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Q:确定内核初始化堆栈的位置，以及堆栈在内存中的确切位置。内核如何为其堆栈保留空间？堆栈指针初始化指向这个保留区域的哪个“端”？
</span></span></code></pre></td></tr></table>
</div>
</div><p>#结论</p>
<ol>
<li>entry.S 77行初始化栈</li>
<li>栈的位置是0xf0108000-0xf0110000</li>
<li>设置栈的方法是在kernel的数据段预留32KB空间(entry.S 92行)</li>
<li>栈顶的初始化位置是0xf0110000</li>
</ol>
<p>#分析 bootloader最后一条语句进入内核，进入内核后的几件事情顺序如下：</p>
<ol>
<li>开启分页(entry.S 62行)</li>
<li>设置栈指针(entry.S 77行)</li>
<li>调用i386_init(entry.S 80行)</li>
</ol>
<p>设置栈指针的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    # Set the stack pointer
</span></span><span class="line"><span class="cl">    movl    $(bootstacktop),%esp
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以从kern/kernel文件中找出符号bootstacktop的位置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">zzzz@ubuntu:~/workspace/github/xv6-note/Lab1/2014-jos-Lab1$ objdump -D obj/kern/kernel | grep -3 bootstacktop
</span></span><span class="line"><span class="cl">f0108000 &lt;bootstack&gt;:
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">f0110000 &lt;bootstacktop&gt;:
</span></span><span class="line"><span class="cl">f0110000:       01 10                   add    %edx,(%eax)
</span></span><span class="line"><span class="cl">f0110002:       11 00                   adc    %eax,(%eax)
</span></span><span class="line"><span class="cl">        ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为没有设置CS，因此CS还是指向之前在bootloader阶段设置的数据段描述符，该描述符指定的基地址为0x0，因此%esp的值就是栈顶的位置。因此栈顶的位置就是0xf0110000。 堆栈的大小由下面的指令设置(entry.S 92行):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.data
</span></span><span class="line"><span class="cl">###################################################################
</span></span><span class="line"><span class="cl"># boot stack
</span></span><span class="line"><span class="cl">###################################################################
</span></span><span class="line"><span class="cl">    .p2align    PGSHIFT     # force page alignment
</span></span><span class="line"><span class="cl">    .globl      bootstack
</span></span><span class="line"><span class="cl">bootstack:
</span></span><span class="line"><span class="cl">    .space      KSTKSIZE
</span></span><span class="line"><span class="cl">    .globl      bootstacktop   
</span></span><span class="line"><span class="cl">bootstacktop:
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出，栈的设置方法是在数据段中预留出一些空间来用作栈空间。memlayout.h 97行定义的栈的大小:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#define PGSIZE      4096        // bytes mapped by a page
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">#define KSTKSIZE    (8*PGSIZE)          // size of a kernel stack
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此栈大小为32KB，栈的位置为0xf0108000-0xf0110000</p>
<p>#gdb验证 调用call i386_init函数的位置为0xf0100039，在该位置设置断点，查看寄存器内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(gdb) b *0xf0100039
</span></span><span class="line"><span class="cl">Breakpoint 1 at 0xf0100039: file kern/entry.S, line 80.
</span></span><span class="line"><span class="cl">(gdb) c
</span></span><span class="line"><span class="cl">Continuing.
</span></span><span class="line"><span class="cl">The target architecture is assumed to be i386
</span></span><span class="line"><span class="cl">=&gt; 0xf0100039 &lt;relocated+10&gt;:   call   0xf010009d &lt;i386_init&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Breakpoint 1, relocated () at kern/entry.S:80
</span></span><span class="line"><span class="cl">80              call    i386_init
</span></span><span class="line"><span class="cl">(gdb) info r
</span></span><span class="line"><span class="cl">eax            0xf010002f       -267386833
</span></span><span class="line"><span class="cl">ecx            0x0      0
</span></span><span class="line"><span class="cl">edx            0x9d     157
</span></span><span class="line"><span class="cl">ebx            0x10094  65684
</span></span><span class="line"><span class="cl">esp            0xf0110000       0xf0110000 &lt;entry_pgdir&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，调用函数i386_init之前，栈的位置确实是在0xff010000(%esp)。查看栈的内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(gdb) x /8xw 0xf010fff0
</span></span><span class="line"><span class="cl">0xf010fff0:     0x00000000      0x00000000      0x00000000      0x00000000
</span></span><span class="line"><span class="cl">0xf0110000 &lt;entry_pgdir&gt;:       0x00111021      0x00000000      0x00000000      0x0000000
</span></span></code></pre></td></tr></table>
</div>
</div><p>第一个压入栈的数据应该是call i386_init的返回地址，即这条指令的下一条指令的地址，stepi单步之后再查看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(gdb) x /8xw 0xf010fff0
</span></span><span class="line"><span class="cl">0xf010fff0:     0x00000000      0x00000000      0x00000000      0xf010003e
</span></span><span class="line"><span class="cl">0xf0110000 &lt;entry_pgdir&gt;:       0x00111021      0x00000000      0x00000000      0x00000000
</span></span><span class="line"><span class="cl">(gdb) x /2i 0xf0100039
</span></span><span class="line"><span class="cl">   0xf0100039 &lt;relocated+10&gt;:   call   0xf010009d &lt;i386_init&gt;
</span></span><span class="line"><span class="cl">   0xf010003e &lt;spin&gt;:   jmp    0xf010003e &lt;spin&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>再次查看栈中的内容验证了之前的猜测。</p>
<h3 id="exercise10">exercise10</h3>
<p>在test_backtrace(5)出打上断点即0xf01000f0，随后查看寄存器$esp为0xf010ffe0</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">*// Test the stack backtrace function (lab 1 only)*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">​    test_backtrace(5)*;*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">f01000f0:   c7 04 24 05 00 00 00    movl   $0x5,(%esp)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">f01000f7:   e8 44 ff ff ff          call   f0100040 &lt;test_backtrace&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">f01000fc:   83 c4 10                add    $0x10,%esp
</span></span></code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111264.png"
        data-srcset="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111264.png, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111264.png 1.5x, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111264.png 2x"
        data-sizes="auto"
        alt="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111264.png"
        title="image-20230425211123200" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">		mon_backtrace(0, 0, 0);
</span></span><span class="line"><span class="cl">f0100097:	83 ec 04             	sub    $0x4,%esp
</span></span><span class="line"><span class="cl">f010009a:	6a 00                	push   $0x0
</span></span><span class="line"><span class="cl">f010009c:	6a 00                	push   $0x0
</span></span><span class="line"><span class="cl">f010009e:	6a 00                	push   $0x0
</span></span><span class="line"><span class="cl">f01000a0:	e8 0c 08 00 00       	call   f01008b1 &lt;mon_backtrace&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后再mon_backtrace函数上打上断点，查看esp寄存器的值。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111220.png"
        data-srcset="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111220.png, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111220.png 1.5x, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111220.png 2x"
        data-sizes="auto"
        alt="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111220.png"
        title="image-20230425211431063" /></p>
<p>反汇编代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">test_backtrace(int x)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">        cprintf(&#34;entering test_backtrace %d\n&#34;, x);
</span></span><span class="line"><span class="cl">        if (x &gt; 0)
</span></span><span class="line"><span class="cl">                test_backtrace(x-1);
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">                mon_backtrace(0, 0, 0);
</span></span><span class="line"><span class="cl">        cprintf(&#34;leaving test_backtrace %d\n&#34;, x);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">f0100040:       55                      push   %ebp                             ;压入调用函数的%ebp
</span></span><span class="line"><span class="cl">f0100041:       89 e5                   mov    %esp,%ebp                        ;将当前%esp存到%ebp中，作为栈帧
</span></span><span class="line"><span class="cl">f0100043:       53                      push   %ebx                             ;保存%ebx当前值，防止寄存器状态被破坏
</span></span><span class="line"><span class="cl">f0100044:       83 ec 14                sub    $0x14,%esp                       ;开辟20字节栈空间用于本函数内使用
</span></span><span class="line"><span class="cl">f0100047:       8b 5d 08                mov    0x8(%ebp),%ebx                   ;取出调用函数传入的第一个参数
</span></span><span class="line"><span class="cl">f010004a:       89 5c 24 04             mov    %ebx,0x4(%esp)                   ;压入cprintf的最后一个参数，x的值
</span></span><span class="line"><span class="cl">f010004e:       c7 04 24 e0 19 10 f0    movl   $0xf01019e0,(%esp)               ;压入cprintf的倒数第二个参数，指向格式化字符串&#34;entering test_backtrace %d\n&#34;
</span></span><span class="line"><span class="cl">f0100055:       e8 27 09 00 00          call   f0100981 &lt;cprintf&gt;               ;调用cprintf函数，打印entering test_backtrace (x)
</span></span><span class="line"><span class="cl">f010005a:       85 db                   test   %ebx,%ebx                        ;测试是否小于0
</span></span><span class="line"><span class="cl">f010005c:       7e 0d                   jle    f010006b &lt;test_backtrace+0x2b&gt;   ;如果小于0，则结束递归，跳转到0xf010006b处执行
</span></span><span class="line"><span class="cl">f010005e:       8d 43 ff                lea    -0x1(%ebx),%eax                  ;如果不小于0，则将x的值减1，复制到栈上
</span></span><span class="line"><span class="cl">f0100061:       89 04 24                mov    %eax,(%esp)                      ;接上一行
</span></span><span class="line"><span class="cl">f0100064:       e8 d7 ff ff ff          call   f0100040 &lt;test_backtrace&gt;        ;递归调用test_backtrace
</span></span><span class="line"><span class="cl">f0100069:       eb 1c                   jmp    f0100087 &lt;test_backtrace+0x47&gt;   ;跳转到f0100087执行
</span></span><span class="line"><span class="cl">f010006b:       c7 44 24 08 00 00 00    movl   $0x0,0x8(%esp)                   ;如果x小于等于0，则跳到这里执行，压入mon_backtrace的最后一个参数
</span></span><span class="line"><span class="cl">f0100072:       00 
</span></span><span class="line"><span class="cl">f0100073:       c7 44 24 04 00 00 00    movl   $0x0,0x4(%esp)                   ;压入mon_backtrace的倒数第二个参数
</span></span><span class="line"><span class="cl">f010007a:       00 
</span></span><span class="line"><span class="cl">f010007b:       c7 04 24 00 00 00 00    movl   $0x0,(%esp)                      ;压入mon_backtrace的倒数第三个参数
</span></span><span class="line"><span class="cl">f0100082:       e8 68 07 00 00          call   f01007ef &lt;mon_backtrace&gt;         ;调用mon_backtrace，这是这个练习需要实现的函数
</span></span><span class="line"><span class="cl">f0100087:       89 5c 24 04             mov    %ebx,0x4(%esp)                   ;压入cprintf的最后一个参数，x的值
</span></span><span class="line"><span class="cl">f010008b:       c7 04 24 fc 19 10 f0    movl   $0xf01019fc,(%esp)               ;压入cprintf的倒数第二个参数，指向格式化字符串&#34;leaving test_backtrace %d\n&#34;
</span></span><span class="line"><span class="cl">f0100092:       e8 ea 08 00 00          call   f0100981 &lt;cprintf&gt;               ;调用cprintf函数，打印leaving test_backtrace (x)
</span></span><span class="line"><span class="cl">f0100097:       83 c4 14                add    $0x14,%esp                       ;回收开辟的栈空间
</span></span><span class="line"><span class="cl">f010009a:       5b                      pop    %ebx                             ;恢复寄存器%ebx的值
</span></span><span class="line"><span class="cl">f010009b:       5d                      pop    %ebp                             ;恢复寄存器%ebp的值
</span></span><span class="line"><span class="cl">f010009c:       c3                      ret                                     ;函数返回
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个栈帧(stack frame)的大小计算如下：</p>
<ol>
<li>在执行call test_backtrace时有一个副作用就是压入这条指令下一条指令的地址，压入4字节返回地址</li>
<li>push %ebp，将上一个栈帧的地址压入，增加4字节</li>
<li>push %ebx，保存ebx寄存器的值，增加4字节</li>
<li>sub $0x14, %esp，开辟20字节的栈空间，后面的函数调用传参直接操作这个栈空间中的数，而不是用pu sh的方式压入栈中</li>
</ol>
<p>加起来一共是32字节，也就是8个int。因此上面打印出来的栈内容，每两行表示一个栈帧，看v起来还算清晰。</p>
<p>#第一次调用分析 以第一调用栈为例分析，32个字节代码的含义如下图所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0xf010ffc0:     0x00000004      0x00000005      0x00000000      0xf010004e
</span></span><span class="line"><span class="cl">0xf010ffd0:     0xf0111308      0x00010094      0xf010fff8      0xf01000fc
</span></span><span class="line"><span class="cl">             +--------------------------------------------------------------+
</span></span><span class="line"><span class="cl">             |    next x    |     this x     |  don&#39;t know   |  don&#39;t know  |
</span></span><span class="line"><span class="cl">             +--------------+----------------+---------------+--------------+
</span></span><span class="line"><span class="cl">             |  don&#39;t know  |    last ebx    |  last ebp     | return addr  |
</span></span><span class="line"><span class="cl">             +------ -------------------------------------------------------+
</span></span></code></pre></td></tr></table>
</div>
</div><p>中间的两字节不知道是干嘛用的(靠近this x的那一个在调用mon_backtrace时会用到)，按照理论分析，一个完整的调用栈最少需要的字节数等于4+4+4+4*3=24字节，即返回地址，上一个函数的ebp，保存的ebx，函数内没有分配局部变量，需要再加12个字节用来调用mon_backtrace时传参数。</p>
<p>有一个说法是，因为x86的栈大小必须是16的整数倍，所以才分配了32个字节的栈大小。</p>
<h3 id="exercise11">exercise11</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111744.png"
        data-srcset="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111744.png, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111744.png 1.5x, https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111744.png 2x"
        data-sizes="auto"
        alt="https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202310312111744.png"
        title="image-20230426103040997" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">--- a/Lab1/2014-jos-Lab1/kern/monitor.c
</span></span><span class="line"><span class="cl">+++ b/Lab1/2014-jos-Lab1/kern/monitor.c
</span></span><span class="line"><span class="cl">@@ -58,8 +58,17 @@ mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
</span></span><span class="line"><span class="cl"> int
</span></span><span class="line"><span class="cl"> mon_backtrace(int argc, char **argv, struct Trapframe *tf)
</span></span><span class="line"><span class="cl"> {
</span></span><span class="line"><span class="cl">-    // Your code here.
</span></span><span class="line"><span class="cl">-    return 0;
</span></span><span class="line"><span class="cl">+    uint32_t ebp, *p;
</span></span><span class="line"><span class="cl">+
</span></span><span class="line"><span class="cl">+    ebp = read_ebp();
</span></span><span class="line"><span class="cl">+    while (ebp != 0)
</span></span><span class="line"><span class="cl">+    {
</span></span><span class="line"><span class="cl">+        p = (uint32_t *) ebp;
</span></span><span class="line"><span class="cl">+        cprintf(&#34;ebp %x eip %x args %08x %08x %08x %08x %08x\n&#34;, ebp, p[1], p[2], p[3], p[4], p[5], p[6]);
</span></span><span class="line"><span class="cl">+        ebp = p[0];
</span></span><span class="line"><span class="cl">+    }
</span></span><span class="line"><span class="cl">+    
</span></span><span class="line"><span class="cl">+    return 0;
</span></span><span class="line"><span class="cl"> }
</span></span></code></pre></td></tr></table>
</div>
</div><p>先把ebp寄存器中存的地址存入ebp中并打印出来，然后把返回地址即ebp+4的地址打印出来，随后是args[1-5]。最后将ebp存的地址所指向的内容即上一个调用者的ebp地址赋值给ebp寄存器</p>
<h3 id="exercise12">exercise12</h3>
<ul>
<li>仿照debuginfo_eip中的其他操作写出给eip_line赋值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);
</span></span><span class="line"><span class="cl">	if (lline &lt;= rline)
</span></span><span class="line"><span class="cl">		info-&gt;eip_line = stabs[lline].n_desc;
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		cprintf(&#34;lline &gt; rline\n&#34;);
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>随后修改monitor.h中的Command结构体</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">static struct Command commands[] = {
</span></span><span class="line"><span class="cl">	{&#34;help&#34;, &#34;Display this list of commands&#34;, mon_help},
</span></span><span class="line"><span class="cl">	{&#34;kerninfo&#34;, &#34;Display information about the kernel&#34;, mon_kerninfo},
</span></span><span class="line"><span class="cl">	{&#34;backtrace&#34;, &#34;Display information about the stack&#34;, mon_backtrace},
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>最后在mon_backtrace函数中打印出函数名，函数所在的行等信息</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int mon_backtrace(int argc, char **argv, struct Trapframe *tf)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	// Your code here.
</span></span><span class="line"><span class="cl">	uint32_t ebp = read_ebp();
</span></span><span class="line"><span class="cl">	uint32_t eip = 0;
</span></span><span class="line"><span class="cl">	struct Eipdebuginfo info;
</span></span><span class="line"><span class="cl">#define TO_INT(x) *((uint32_t *)(x))
</span></span><span class="line"><span class="cl">	while (ebp)
</span></span><span class="line"><span class="cl">	{
</span></span><span class="line"><span class="cl">		eip = TO_INT((ebp + 4));
</span></span><span class="line"><span class="cl">		// ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031
</span></span><span class="line"><span class="cl">		cprintf(&#34;ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&#34;,
</span></span><span class="line"><span class="cl">				ebp,		 /*ebp*/
</span></span><span class="line"><span class="cl">				eip,	 /*eip*/
</span></span><span class="line"><span class="cl">				TO_INT((ebp + 8)),	 /*arg1*/
</span></span><span class="line"><span class="cl">				TO_INT((ebp + 12)),	 /*arg2*/
</span></span><span class="line"><span class="cl">				TO_INT((ebp + 16)),	 /*arg3*/
</span></span><span class="line"><span class="cl">				TO_INT((ebp + 20)),	 /*arg4*/
</span></span><span class="line"><span class="cl">				TO_INT((ebp + 24))); /*arg5*/
</span></span><span class="line"><span class="cl">		if(!debuginfo_eip(eip, &amp;info))
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			cprintf(&#34;%s:%d: %.*s+%d\n&#34;, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		else
</span></span><span class="line"><span class="cl">		{
</span></span><span class="line"><span class="cl">			cprintf(&#34;debuginfo_epi error\n&#34;);
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		ebp = TO_INT(ebp);
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return 0;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2023-10-31</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/6.828_lab1/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://www.zhouxingjie.work/6.828_lab1/" data-title="6.828_lab1"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://www.zhouxingjie.work/6.828_lab1/"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://www.zhouxingjie.work/6.828_lab1/" data-title="6.828_lab1"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://www.zhouxingjie.work/6.828_lab1/" data-title="6.828_lab1"><i data-svg-src="/lib/simple-icons/icons/line.min.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://www.zhouxingjie.work/6.828_lab1/" data-title="6.828_lab1"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav">
            <a href="/6.828_lab2/" class="next" rel="next" title="6.828_lab2">6.828_lab2<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.120.1">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2019 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">zhouxingjie</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/mhchem.min.js"></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
